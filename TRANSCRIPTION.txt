jQuery Animation

Introduction to jQuery Animation

Welcome to this Pluralsight course titled jQuery Animation. My name is Mark Zamoyta, and I'll be walking you through most of jQuery's effects and animation features. jQuery makes it extremely easy to put elements on your web pages into motion. If we take a quick look at the jQuery documentation page at api.jquery.com, you'll see this Effects section, and this is where all of jQuery's animation methods live. This course has eight modules, which I'll quickly cover now. This is the Introduction Module, and in Module 2 we'll cover the most simple yet powerful jQuery animation methods. You'll learn to make DOM elements show and hide, fade in and out, or perform other animations with just a single method call. In Module 3, I'll talk about easing. We'll get an easing plug-in for jQuery and work on getting DOM elements to move more fluidly. We'll also give DOM elements bouncing and elastic animations using easing. We'll even create some of our own easing functions as jQuery plug-ins. In Module 4, we'll cover advanced jQuery animation methods including 2D and 3D rotations, animating colors and other non-numeric CSS properties, working with animation queues and promises. Module 5 is the first of four practical modules where we'll build useful animation controls. We'll use jQuery and Font Awesome to create the animated Buy Now button you see here. In Module 6, we'll build this animation picture gallery using jQuery. I'm using illustrations of the 12 zodiac signs, but it will work with any image files. In Module 7, we'll create this animated pie chart. We'll draw the pie slices in HTML 5 canvases, and we'll set up a simple state machine to control our animations. In Module 8, we'll build and optimize a simple Sprite engine. We'll use jQuery to set up our DOM elements, but we'll take full control over our animation loop. We'll use the Chrome browser's profiler to optimize our Sprite engine and really improve performance. I hope you enjoy this course and learn how to make the most out of jQuery's animation features.

Prerequisites and Tools

For this course, you should have a fundamental understanding of HTML, CSS, and JavaScript. You should also be somewhat familiar with jQuery. I'll explain basic jQuery concepts in this course as they arise, but I won't go into them in detail. I'll mainly be going into detail on the animation-related jQuery methods. There are several Pluralsight courses that cover the fundamentals of jQuery and web development, so check those out if you need to brush up on fundamentals. For tools, I'm using Visual Studio Express, which is a free tool you can get at Microsoft's website, but any text editor and browser will work. I mainly use Internet Explorer and Chrome is used in the last module because I prefer its profiler.

Simple jQuery Animation

Introduction

Welcome to this module titled Simple jQuery Animation. jQuery makes animating DOM elements very easy. When we're surfing the internet, we always see content fading in and out, sliding up and down, and slowly animating into position. These simple animations are usually accomplished with just one line of code in jQuery, and in some cases you don't even need a new line of code. You can just use chaining on a jQuery object to append a simple animation method. In this module, we'll look at the simple yet powerful animation methods built into jQuery. We'll use a single method call to show, hide, and toggle DOM elements. We'll see how to fade our DOM elements in and out and slide elements up and down. Then we'll look at jQuery's animate method, which lets us perform more complex animations. We'll see how to animate the values of any numeric CSS property with this method. Animations can be chained together so that they're run sequentially. We'll take a look at creating more complex animations with chaining, and we'll look at how to stop a long- running animation gracefully.

Show, Hide and Toggle Methods

So, the first jQuery functions we're going to look at for animation are show and hide. I created our default project, and you can see that I added Bootstrap and jQuery, and let me add some more content now. So, I added a paragraph, an input button, and two more paragraphs. Let's take a look at this. So, what we want to have happen is when we click the Animate button, we want this text here to hide and show, toggle back and forth basically. So, let's see how we do that. First off, I'll add a class to the input to make it look more like a Bootstrap button, and we'll take the text that we want to animate, this paragraph right here, and let's give it an ID of animate. Now, because we're working in jQuery, I'll add some script at the bottom here. We grab the jQuery object for input, which is our button up here, and we attach a handler to the click event. So, this function will execute whenever we click the button. We take the animate object, which is our paragraph, Text to animate, and we assign that to the variable A, and then we start using the variable A. If A. is hidden, this is a jQuery function that tells us whether or not an object is hidden or not, then we want to show that object. So, show is an animation method, which is part of jQuery. Otherwise, we want to hide the object. So, essentially our input is going to become a toggle. Our button will toggle on and off the visibility with the show and hide functions, so let's take a look. I'll click the animate button, and we can see the text appear and disappear as we click it. Now, that's not really animated and it looks a little bit jerky, and let's get it to be smooth. Our show and hide functions accept several different arguments. Let's start off with a fast parameter. We'll pass in the string fast to each one. And now when we hit the button we can see it quickly hiding and showing. We can also pass in the string slow. And that's the same animation, just slower. And here we can see that the text actually fades a little bit as it disappears, and it fades back in as it shows. So, we're not limited to these arbitrary fast and slow values. We can put any number of milliseconds in here. Let's go for 3 seconds. A millisecond is a 1000 --- there are 1000 milliseconds in a second, so 3000 milliseconds will be 3 seconds. And I'll do that both for the show and hide. So, now it takes 3 seconds to hide, and it takes 3 seconds to show. So, obviously we're not limited to just text to animate. We can animate pretty much anything. Let's wrap this in a div. I'll surround it with HTML div, and let's move this ID and put that on the div instead. And we can add more content in here. So, I added a div. The ID is box, and it's an empty div, but I also added a style up in our head section. So, if we look at the style, we're setting the width and height to 200 pixels each, and we're setting the background-color to red so that we can see it. And, again, remember both this paragraph and the div are now wrapped in this other div right here whose ID is set to animate. I'll just clean that up. Let's run it. So, now we can see our div and our text, and we hit the Animate button to hide both of them, and we can show them again too. Now, this is a pretty common pattern to like show and hide elements in an HTML page, so there's actually a shortcut we can do. Let me show you that. So, I edited the code to this one single line. We're grabbing our animate object, which is our div up here, and we're calling toggle. And what toggle will do is it'll alternate between showing and hiding the element and will also pass it a slow instead of 3 seconds. And we'll run this. And now we can see it works exactly the same way, but only in that one line of code. So, this is a really powerful animation function, toggle. You see it in a lot of websites, and all you have to do is take your jQuery object and call the toggle function.

Fade Methods

Next, we're going to look at jQuery's fade functions. You can fade objects in or fade objects out or fade to a specific opacity. Let's start with the project from the last video, and let's modify this. Just like in the last video, we're going to handle the click event for our button, and we'll set the variable A equal to our animate div, which is right here, and that's what we're going to animate. And if A is hidden, we're going to fade it in or else we're going to fade it out. And we'll fade it in and out over the span of 1 second, 1000 milliseconds. So, let's run this. I'll click the Animate button, and it fades out, and it fades back in. Now, you'll notice that the text below the animation jumps when we animate in or out, and we don't want that really. The best thing to do would be to use the show and hide, but if all you want is fading, most likely you wouldn't have content beneath it or it wouldn't be part of the normal flow of the document. So, let's take a look at this. Let's take our div animate and absolutely position it. I'll add the code for that. Okay, so I went up to the top of the document and I added another style for the animate object, and we used the pound sign because this is an ID. If we were using a class like here, then we would use a dot, but we're using the pound symbol because it's an ID. And we set the position to absolute. That'll let us position this anywhere on the page outside of the flow of the document, and we'll set a left coordinate of 200 pixels and a top coordinate of 200 pixels as well. And let's run this. So, now we have our div positioned at 200, 200, and it's outside the flow so we won't see the text below animation move like we did before, and this is working fine. So, you'd probably want to use this for some kind of dialog box or some kind of picture that you're overlaying on your website, but because of that problem of fading it in and out and having the anything underneath it jump, you're best off using the show and hide for that. But if you have something that is absolutely positioned, then you can animate it this way with the fade in or fade out. Now, just like with show and hide, we can also get rid of all this code because it's a very common pattern. I'll just fix up the code here. So, we're taking our animate object, and we're calling fadeToggle, and that'll toggle the fade in and fade out, and I'm setting the parameter to fast. So, now when we click the Animate button, it quickly fades in and fades out. So, again, that's another powerful jQuery command. You might use this often, and you can get it down to just this one line of code with this fadeToggle function. Now another function that's part of the fading functions is fadeTo, and this will let us fade to a specific opacity. So, let's make this slow, and then we'll set the opacity, and we'll set it to let's say 0.5. So, that'll make it semi-transparent, halfway. I'll click the Animate button, and now it's half faded out. So, that's a good way to animate it to a faded state. And to see that again, I'll just Refresh the page, and I'll click the Animate button, and it gradually animated to being halfway faded out. So, just make sure you pass the duration, slow, fast or the number of milliseconds, followed by the opacity, which is a number from 0 being invisible to 1. Let me just set it 0.2, and it'll be almost faded out now. There we go.

Slide Methods

So, now we're going to look at the jQuery animations for sliding. We can slide DOM elements up or down or we can toggle between the two. So, looking at this code, this uses the toggle function, which is used to show and hide. We've already seen this, but let's just run it and make sure we see how it works here. I'll click the Animate button, and we can see that the items slide up and down and they hide and show by changing the height of the object, and we'll also notice that it fades out as it hides, and it fades in as it comes in. So, we have the changing of the height and also the fading. Now, there's a function called slideToggle, which does the same thing without the fading, so let's run this. Now we get the element sliding up and down, and it's not fading at all. And it's totally up to you whether you want to use the regular toggle or the slideToggle. Also, we have functions called slideUp and slideDown, and I'll paste the code for that. So, I commented out the code that was there, and I added this code, which is the same pattern we have seen before. We're on the click event for the input button, and we grabbed the jQuery object called A for animate. And if A is hidden, then we want to slide it down; else, we want to slide it up. So, let's take a look. I'll click the button, and it slides up, and it slides down. And as I do this, you can see that it is not fading. So, if you wanted the fading, you would just use show and hide or you can just use slideUp and slideDown. Probably one of the reasons why you would use slideUp and slideDown other than using slideToggle if you wanted to change the duration. So, let's change this duration to 300 to make it slide up really quick, get out of the way quickly. So, it slides down slowly, and it slides up quickly. So, those are our slide functions, slideToggle, slideUp, and slideDown.

The animate() Method

So, now we're going to look at jQuery's animate function. The animate function is used to animate any numerical CSS value, and we've already seen this with the previous videos. When we called the show or hide functions or we called the fade and slide functions, those would animate CSS values as well. But with the animate function, you specifically select which value you want to animate. Some common CSS values include the top and left. This would enable you to position an element anywhere on the website if it was absolutely positioned. Also, it's common to see the width and height of elements suggested or animated. We've seen how the opacity was animated, especially with the fade function, and now we can get more control over it with the animate function. We also can do any CSS value such as fontSize, borderWidth, and dozens of other ones. It's interesting to see that with fontSize and borderWidth we've taken out the hyphens and we've converted it to CamelCase. So, for fontSize, we took out the hyphen, and we added an uppercase S. And this is required for JavaScript and jQuery to handle the variable names properly within JavaScript. And the same with borderWidth. Take out the hyphen and convert it to CamelCase with a capital W. So, let's look at some demos where we modify these values and animate them. So, we're starting up with our start up project, and we have Bootstrap, and we have jQuery loaded in. Everything else has been blanked out. Another thing I did was I added an image. So, if we look in Content and images, I added logo-v2.png, and this is the Pluralsight logo that we see right here. And we're going to use this for some of our animation right now. So, let's drag the logo and drop it into our body, and now we have the image. Now, let's start by animating the left and top properties. In order to do that, this needs to be absolutely positioned. So, I'll add some style for the image, and now it's absolutely positioned. We can specify the left and top properties for it, and it will move around the browser. So, I'll go down to our script section, and I'll enter some code. So, looking at the code I entered, we're grabbing an image or all of the images in this document, and we only have one, and we're going to animate it. We're going to take the left property. Now, this first parameter is a JavaScript object. It's inside the curly braces, and we specify left colon and the value we want it to animate to. So, when it starts off, the left is going to be set to 0, and we want it to animate to 300 pixels over the time span of 3000 milliseconds, which will be 3 seconds. So, let's run this. So, we have our logo, and it animates across the screen to X coordinate 300 over the time span of 3 seconds. Now, we can animate more then just one property. This is an object, so we can treat it as a list of values. We can put a comma, and let's make the top also go to 300. So, now we're animating both values, both the left and the top. And I'll just Refresh it, and you can see it moves diagonally to the coordinates 300, 300. Now, I'll enter some more code. So, I added this paragraph tag here. It just says here's some text, and down below we animate this as well. We grab our P tag, we call the animate function, and we pass it the object which contains fontSize, and we're setting the fontSize to 88 pixels over the time span of 2 seconds. So, let's watch this animation. And I'll show it again. So, here we have an example of two animations happening at the same time, and we are getting this font size really big here. So, to review this, we call animate on a jQuery object or a list of objects and we pass in an object which can have multiple name value pairs. A lot of times you'll see the name value pairs listed out like this just because they're easier to read. This way we could easily add things like let's say opacity. Let's move that down to 0, and let's run it. So, now Pluralsight fades out as it moves down to the lower right. So, that's the animate function, and we can add any CSS value here as long as it's numeric. We'll see in an advanced module how we can animate non-numeric CSS fields.

animate() Parameters

So, let's look at jQuery's animate function in more detail. I'm at the jquery.com website, and let's click on the API Documentation and search for animate and get the animate function. So, let's look at the parameters in more detail here. First of all, the .animate. The dot means that it's called off of a jQuery object, so it's going to be one or more than one DOM objects that you can animate at a time. And looking down here at the properties or the parameters, we can see the first parameter is the properties, and that's what we've already seen in the prior video. Now, these square brackets around the parameters mean they're optional, so we pass in an optional duration and then an optional easing function and an optional complete function. Well, actually, the easing will just be a string that relates to a function, and complete is an actual function that we'll pass in, and it returns another jQuery object. So, the good thing about returning a jQuery object is that we can chain it, and down here in the more detailed function description we can see the little chain icon so that it does show that we can chain it. And we'll probably be taking a look at that in a more advanced module. But for now, these parameters are the same as right here, and let's take a look at these in detail. There is another way to call animate, which is we can pass it properties and options, and we'll look at this in the next video, but for now let's examine each one of these parameters. So, the first one, we know our properties are required, is the duration, so let's go to the code. So, here we have the project from the last video, and let's just fix this up a bit. I'll take out the paragraph here, and I'll take out the animation for it, and I don't want to animate the opacity for this, and let's just put the duration on its own line. Just to make sure we know what we have, let's run it. So, over 3 seconds we're animating the Pluralsight to 300, 300, which is similar to our last video. So, this duration is optional. Let's take that out and see what happens. So, now we're only passing it the first property's parameter. And we'll run it. And you can see it was pretty quick. That looks like the default is set to fast for that. We can also set the duration to the built-in slow if we want to, and that's still pretty fast, but it's not as fast as the default. And as we saw, we can just specify a number of milliseconds. We'll put in 2000 milliseconds for 2 seconds, and we get a 2 second animation. So, we have our duration and properties, and now let's look at the easing. Easing is optional, and it defaults. If you look down here, it defaults to an easing style called swing. And in jQuery there are two easings that are built in, swing and linear, and we'll take a look at those, but there's a whole module dedicated to easing in this course. So, if you want to look at easing in more detail definitely check out that module. So, back to the code. Let's add two images so we can compare them. Let's look at what I did here. I added image 1, which now has an ID of img1, and we duplicated the same image as img2. And then up in the style section I added a CSS selector for the img2, and we just want to make sure that it's lower than the first image, so we set the top to 150 pixels. And then down in our script section we're going to animate the left side over 2 seconds to 300 pixels. Now, in this first one, I'll use swing, which will be the default easing, and on the second one I'll use linear. So, let's run this. And remember the swing easing will be on top, and the linear easing will be on the bottom. Alright, so they're obviously different. I'll run it again, and they both end at the same time and start at the same time, but let's watch the bottom one. The bottom on is linear, and that's going to move straight across with no modification whatsoever. It's just going to move in a linear line with no acceleration or deceleration. If we focus on the top one, this will be our swing animation. You can see it gets off to a slow start. It eases into the amination, and then it eases out of the animation. So, let's focus on the top one now and watch it ease in and ease out. So, the top animation is the default, and it looks more natural like that's way you would see objects move if you move your body or if you pick an object or something. Normally it's not going to be a perfectly linear pattern. That looks very robotic, and it's a lot more aesthetic to see the acceleration and deceleration of the easing. And like I mentioned, we'll have a whole module on easing. So, let's look back at our documentation on this again. We saw the properties, duration, easing, and the last parameter, which is optional, is complete. And this is a function that's going to get called when the animation is completed. So, let's take a look at that. I'll take our first animation and add a function to the end. So, I added this function, and we're only adding it to image number 1. And after our easing we have our complete function, which gets called when the animation is completed. And we're just grabbing the jQuery object for the body of the page, and we're appending we are done. So, let's run this. The animation happens, and at the end we are done shows up in the page right here. And I'll just run that again, and we see it. We are done is added as an element to the page. Now, these arguments are all optional. We can take out the duration and the easing, and it'll just use the defaults. It's smart enough to know that this is a function and the middle two arguments are missing. So, let's run this. And we see the first one goes across really quick, and we are done shows up. I'll run it again. So, that's the animate function. You have to tell it what properties that we're going to animate, and the duration, easing, and complete function are all optional.

animate() Options

Now we're going to look at the other way to call the animate method or function on a jQuery object. We saw the first way, this top way in the previous video, and now we'll take a look at the second way, which has two parameters, properties and options. The properties are the CSS properties, same as the first function, and options are described here. We have many options to choose from, and they're all optional. We can set the duration and easing. And we saw these in the first way to call this method has duration and easing. And we can specify a queue. We'll cover this in a future video, but essentially what a queue is it queues up your animations so that they play one after the other, and you're allowed to have more than one queue on an animation. We'll take a look at specialEasing in this video. SpecialEasing refers to, well we have easing up here, but what if you have two properties that you're animating? Each property might have its own easing function, and that can't be accomplished with just specifying one easing function, so specialEasing will map the property to the correct easing string, which relates to an easing function. Step, this is a function that we can specify that gets called as the animation steps along, and we'll look at that in this video. Progress is similar to step in that it gives us a progress of how far along the animation is. Complete, this is, we already looked into this in the first method call. It's an optional parameter that is a function that lets us know when the animation has completed. And these final three functions or methods, done, fail, and always, these are all functions and they have to do with promises. We'll be covering these in a future advanced video, but for now a promise is basically an object that lets us know when some kind of asynchronous event has completed or failed. So, these three functions can be specified. And done will get called when the animation is done, fail will get called if the animation failed or the promise was broken or rejected, and always will always get called. And we'll cover these in a future video for sure. So, for now let's look at these options that we haven't seen yet. We'll start with specialEasing. So, here we have our project from the last video, and I'm going to fix this up so that we can see how specialEasing works. So, I modified the code. We only have one logo now, one image, and we're going to animate the left and top CSS properties to 300. Now, we're using the second form of the animate function where the second parameter is a map. So, here we have our jQuery object, and we're going to set the duration to 2000 for 2 seconds. And here's our specialEasing option. We're going to take our left property, which we're setting here to 300 pixels, and we're going to use linear easing on that. And then on the top property we're going to use swing as the easing. So, now we're getting two different easing specifications for the two different properties that we're setting or animating towards. So, let's run this. The motion is pretty subtle, but you can see as it starts it comes out to the right a little bit, then comes down, and then moves more horizontally to the right as it ends. Let's watch it again. So, it kind of follows a curve along this line, down and to the right again, and that's because our easing for the top is set to swing. We can see that the top value stays towards the top at the beginning, and then at the end it stays toward the bottom at the end. So, if it were linear, it would be moving straight down, but instead we have two different easing functions affecting this graphic. Let's look again at our options. So, we've seen specialEasing. Now, let's take a look at step. Step is a function, and the function is going to accept two parameters, a number for now and a tween. So, I modified the code a bit from the last video, and let's take a look at what I did. First I added a paragraph that's empty, and we're only doing one animation, and we're only animating the left CSS property. And it's going to last for 5 seconds, duration is 5 seconds. And here's where I added the stop option. This function is now going to be called for every step along the way of the animation. And when this is called, now will contain the current value of the left or whatever property is being animated, the value of left in this case. So, we're going to set the text of P to now, and let's just watch this. We can see the value grow from 0 all the way up to 300. And I'll do it again. It starts at 0. It goes all the way up to 300. So, the step function is causing this number to refresh itself, and you see that long decimal number in there, but that's fine. And now gets passed in. We also get passed in a tween value. Let's take a look at that. I'll add some code here. So, I added these two lines of code. Tween has a property called position, which is a value between 0 and 1, which is pretty constant along the path of the animation. So, if we're more than halfway done, this position will be greater than 0.5. So, when we're halfway done, we're going to look at this, which is the jQuery element that's being animated, and we're going to call the stop method, which will stop the animation so it'll stop halfway through. Let's run this. So, we got up to a little bit over halfway, 150, and the animation stopped. So, you use this step option to specify a function, which lets you see what's going on. If we set a breakpoint, let's set a breakpoint right on this stop here, and we'll look at our tween value. So, if we look at tween with IntelliSense, we can see that this has a lot of the information that we need for the animation. It tells us the property that's being animated, the easing, the value that it is now, and we actually looked at this position, which is the position of the animation. Not the left value, but a number between 0 and 1, which tells us how far along in the animation we've progressed so far. And you can also look at some of the options here too. You can see the duration and the queue. Yeah, essentially in step you might want to alter your animation based upon the values that are being passed, and step lets you do that. Now, looking back at our documentation, we've seen specialEasing, step, and let's just take a look at progress. So, I modified the code to use the progress option, and that's a function which takes animation, progress, and remaining milliseconds, remainingMs. So, all this does for now is it's going to show our progress, which will be a number between 0 and 1 as the animation progresses. And we can see it increasing from 0 up to 1. We can also show the remainingMs, milliseconds. And that's counting down from 5000. It started at 5 seconds, and it's down to 0. So, looking back at the documentation, we've covered all the options except for queue, which we'll cover soon in another video, and the promise-related functions, done, fail, and always, which will be another module in this course for advanced animation.

Chaining Animations

Now, one thing we can do with animations in jQuery is we can chain them together, have them run one right after the other. So, here's our starting project, and this just has a single image. Let's take a look at it. Okay, so we're using the Pluralsight logo, and what we can do is we can animate it using chaining. So, here's some code that grabs the image, and it hides it. And because the hide method returns a jQuery object, we can chain. We can add another method to it. So, we're going to hide the logo over the course of 1 second, and then we're going to show it over 1 second. And I'll Refresh it. So, we can make long chains of animations and have them run. Let me add the animate function here. So, I added animate, and we're going to animate the left property to 400, and it's going to be over the course of 3 seconds. So, now it will just execute these methods one by one, hide, show, and then animate. Now, another thing we can do is we can put a relative value in for the CSS property. Let's add another animate. So, I decided to split this out and each method in this chain is going to be on its own line. So, it goes hide, show, animate, and then the second animate. If we put a -= in front of a value, this will be a relative value. So, it's going to move to the left, well it's going to change the left CSS position by -200 pixels. Let's run this. And over 2 seconds, it goes left 200 pixels. So, in this first animate method it went to the absolute value of 400 pixels, and in this second one it just subtracted 200 pixels. So, I modified the code so that all of the animations are quicker now. I added 500 milliseconds or half a second to the hide, show, and the two animate methods. Also, I added our new delay method, and so this is going to cause a pause in between these two animate methods for 2 seconds. Let's run it. Now it pauses for 2 seconds, and then it animates back. So, you use the delay method to introduce some kind of delay within your animation, your chained animation. Another thing we could do is we could introduce our own animation or our own code into the middle of this chain. Let me add some code for that. So, I just added this queue method, and this is in the middle of our chain. And what queue does is it lets you introduce a function into the middle of your chain. So, what we're going to do in this function is we're going to take our P element, which is up here, it's empty to start with, and we're going to set the text to here's some text. Now, it's important when you're in the middle of a chain like this that you call dequeue, and this is what tells this function to complete and for the jQuery animation engine to continue with the animation. So, let's run this. And it waits 2 seconds, and you'll notice that the text showed up right after the Pluralsight logo moved to the right. I'll Refresh it. So, it moved to the right and then our text showed up. And then after a 2 second delay it moved back. And a common bug is to forget this dequeue function or method. Let me just comment this out, and we'll see that it hangs up right here. It'll show this text, but it won't continue to the next animate method. So, now we're stuck here. After 2 seconds it's not going to move back because we haven't dequeued this function. We haven't let the animation engine know that we're ready to continue.

Stopping Animations

Now we're going to take a look at stopping an animation. Here we have a big chained animation from the prior video. I fixed a few things on it. For instance, our animate method is going to last a second and a half now in both cases, and I took out our custom queued function. So, let's just run this first and see how it works. The logo moves to the right, and after a 2 second delay it moves back 200 pixels. And I added this stop button up here, which we'll take a look at that now. I added the button here and gave it an ID of stopButton. And then down in our JavaScript code we can see that we're handling the click event, and we're going to call the method stop on our image. And what stop is going to do is it's going to stop the current animation that we're at within this chain. So, let's run it, and I'll stop it right in the middle of this first animate method. And I'll stop. And it stopped immediately, but it continued on with moving it 200 pixels to the left. Let's see that again. I'll Refresh it. It's moving to the right. I'll stop it. And it waits its 2 seconds and moves over to the left. So, one of the parameters we can have to stop is to clear out the queue so that after we stop nothing else will execute after that. And that's the first parameter. We just set that to true. And let's run it. I'll stop it. And now you'll see that we'll wait 2 seconds and it will not move over to the left. This cleared out the queue and it stopped the animation. And there's a second parameter we can pass, which tells us whether we want to jump to the end of the animation, and I'll set that to true too. And I'll run it, and I'll stop it. And you can see when I pressed stop it immediately jumped to the end of that animation. And I'll Refresh it and do that again. Press stop, then it jumped to the end. Now, there's another method we can call instead of stop. We can just call finish and not pass it anything. And what finish does is it also clears out the queue, but before it clears out the queue it'll move the animation to its final position. So, the left CSS parameter will be set to its final destination on finish. And let's see that. I'll hit stop, and it calculated the left value as if it had gone all the way out and then back 200 pixels. And let's see that again. I'll hit stop, and you can see how it jumped into its final position. So, depending upon if you want to clear out the queue or go to its final position, you can use either the stop method or finish.

Summary

In this module, we looked at the simple jQuery methods to show, hide, fade, and slide DOM elements into our JavaScript code. We looked at the animate method in close detail and learned how to animate any numerical CSS property. We also covered this animate method in extreme detail covering most of its many parameters and options. We saw how to chain jQuery animation methods together to create a more complex animated sequence, and we saw how to call stop and finish to end off our animation.

Easing

Introduction

This module is all about easing and easing functions. When we animate a DOM element in jQuery, what we're doing is changing some value over time. Is that change constant over the given time or does it speed up or slow down at any point? Well, easing is what determines how the value changes over time. Easing into an animation determines whether we accelerate quickly or slowly at the start. Easing out of an animation determines whether we accelerate quickly or slowly at the end of the animation. Some cool effects can be created with easing functions such as having your DOM elements bounce or even have an elastic look and feel. The overall purpose of using easing functions is to give our animated DOM elements some more natural or a more whimsical feel. We want to break up the monotony of linear motion, which makes our animations look robotic and mechanical. We want our animations to be enjoyable to watch and move like natural objects. In this module, we'll take a detailed look at easing our animated DOM elements. jQuery only supports two different easing functions, so we'll look at how we can use jQuery UI to get access to many more easings. You may already be using jQuery UI for your project in which case you're set to go. If jQuery UI is too big a package to include in your project, we'll look at a jQuery plugin, which is specifically designed to give you more easing functions and nothing else. Finally, we'll look at how you can modify existing easing functions or create your own easing functions in jQuery.

Easing Definition and Samples

So, what is easing? We're at the website easings.net, and here we have a good definition and a good set of examples where we can actually see different types of easing and how they're viewed visibly. Reading the definition on top, easing functions specify the rate of change of a parameter over time. So, we saw how in animation we're basically changing a CSS property from one numeric value to another one, and how does it change from that first value to the final value. If we look at the top right here, we see linear, and this would cause a change that's always the same. It moves consistently, and it doesn't speed up or slow down. So, let's look at these easing functions here. Here we have one called easeInSine. Now, the red marker, it's having its Y coordinate eased. It's starting at the bottom and going up. And you can see that this starts off a little bit slow like the red marker eases into the animation, and towards the end it's going quicker, but at the beginning of the animation it goes slower. And next we have an easeOutSine. This is where it starts off pretty quick, but by the time it ends it slows down along this part of the curve. Let's see that again. It starts off quick and slows down. And we have many variations of these, but you can come here yourself to easings.net and take a look at how they operate. So, we say in jQuery that there's a default easing called swing, and swing is probably most similar to this one, easeInOutQuad. It eases in a little bit, slow at the beginning, speeds up, and then slows down at the end. Let's see that again. And it's very subtle, but it looks a lot more natural than the linear one above that. And then as we look down the page, there are some more interesting easings. Here we have one called easeInBack. It actually backs up a little bit towards the bottom of the curve here and then quickly reaches the end. Let's see that one again. So, it actually winds up a little bit and reaches the end. EaseOutBack is the opposite. It quickly starts and overshoots the target a little bit and comes back. And easeInOutBack is just both of those put together. It backs up, quickly moves and overshoots its target and slowly moves back into place. Then we get some cool elastic type easings, easeInElastic, easeOutElastic, and then an easeInOutElastic. And then we get bouncing easings and an easeInOutBounce. Now, we can use these easings to make our animation look a lot more interesting. Right now jQuery comes with linear and easeInOutQuad, which they call swing, but we'll see in the rest of this module how we can get access to all these various easing functions and how they look on real objects in a browser.

Easing with jQuery UI

So, let's take a look how we can get all these easings into our jQuery application. Here we have a sample app, and I'll just run it so we can see what it does. It shows the Pluralsight logo, and when I click it, it does a linear animation from the beginning to the end. It moves to, well let's take a look at the code. It starts off at 50 pixels for the left and it animates to 500 pixels, and it does so over 3 seconds with a linear motion, a linear easing. Let's change the easing to swing, and we'll run this. And we can see it gets off to a slow start, and then it speeds up and then slows down towards the end. I'll Refresh it, and we can watch it again. So, those are the only two easings built into jQuery. Let's go back to the easings.net website again. Let's try something like this easeOutBounce. So, I'm adding easeOutBounce as the easing for our animate method now, and we get an error. EaseOutBounce is just not supported. So, how can we get support for easeOutBounce and all these other easings? Well, there are a few ways to do it. One way is to import jQuery UI, and another way is to add some kind of plugin that'll add these easing without having to load the entire jQuery UI library. So, in this video let's just take a look at jQuery UI and adding that to our project. I'll right-click on the application and manage NuGet, and let's look for jQuery UI. And I'll grab this one and install it. And that put it in our Scripts, and let's see here. I'll grab the minified version of it and just drop that in after jQuery. And now let's run our JavaScript app. And now we get our bounce. I'll Refresh it. Do it again. Now we get the nice bounce on the right side that we see in our easeOutBounce. Let's try another one. Let's try this easeInOutBack. So, it winds up a little bit at the beginning, it'll move to the left a little bit, move quickly to the right and overshoot the endpoint, and then slowly come back into place. Let's do that again. It winds up and falls back into place. So, that's probably the easiest way. If you're already using jQuery UI, you already have access to all this, but adding jQuery UI to your project might be a little bit too much. There might be a little too much code in there to slow down your loading time. So, in that case, you might want to just install a plugin with these easings, and we'll see that in the next video.

A jQuery Easing Plug-in

So, instead of loading the entire jQuery UI library, let's just load a plugin. That'll keep our code size down a bit. So, in this project I took out the jQuery UI, that's not even part of the project anymore, and we have easeInOutBounce. So, let's just run this and make sure that we get an error, make sure that easing function doesn't exist. And yeah, it comes out as object doesn't support property or method easeInOutBounce. So, there are few different ways we can get a plugin. One way is to go to the easings.net page. And if we scroll down a bit, we can see right here a link to a jQuery Easing Plugin. Now, we can just click on it here, and this looks minified, but we could copy and paste that or get it in some other way from this page. Probably an easier way since I'm using Visual Studio Express is I'm going to open up the NuGet manager, and I'll search for easings. Searched for easing and we have jQuery Easing comes up. I'll install that. And now if we look in our Scripts folder we can see a jquery.easing.1.3. So, let's put this on our page. And we'll run it. And there we have our easeInOutBounce. Now, if we go to the jquery.easing file, let's take a look at it. What it's doing is it's extending jQuery. So, it's adding these functions right here, and each one of these relates to an easing function or it is an easing function, which relates back to the website here. Like at the end we can see easeInBounce, easeOutBounce, and easeInOutBounce. If we look at the code and scroll down, we can see those here, easeInBounce, easeOutBounce, and easeInOutBounce. So, hopefully just by adding this one plugin we can do away with loading the entire jQuery UI library. In the next video, we'll take a look at actually modifying some of these functions.

Creating Custom Easing Functions

So, we have our easing plugin in place. Now let's take a look at how we can make our own easings. In this project, we're doing an easeOutBack. And let's just take a look and make sure we know how that works. And I'll click it to start it. And it overshoots its target and slowly returns into place. I'll show that again. It overshoots and returns into place slowly. So, what if we wanted it to shoot more, like even go further out to the right? Let's take a look at how we can adjust it that way. If we look in our Scripts folder and we look at jquery.easing, let's find that easing function. It's easeOutBack, which is right here. We can see that there's this arbitrary number here. It seems to be some kind of constant called S that gets used a few times in here. And what happens if we set it to let's just say 4? And now we get it to really overshoot far. I'll play it again. Now it overshoots a lot more. So, it looks like this constant has something to do with like the speed or how far out it goes. Let's make it a lot smaller. Let's make this 0.2 and see what happens. And that barely did anything. It didn't overshoot it at all. Now, you probably don't want to be playing around with these numbers inside of the function directly, so what you could do is copy it and just paste it into its own function. I'll call this one myEaseOutBack, and now I can go ahead and play with this all I want and not have to worry about ruining the original value up here. So, let's check out another animation. Let's do an easeOutBounce. And we see it bounces against the right side. I'll play it again. And it pretty much stays on this line at its final spot and it'll bounce against that. One more time. Okay, so how can we adjust this so that the bounce is a little bit more interesting and it's not hitting up against a wall right there? Let's take a look at that function. Now, when we look at easeOutBounce it's pretty big. There's a lot going on, and for any of these functions they're pretty complex. I mean you've really got to investigate what's going on to see how things work, but one thing I noticed here is that there's this constant 7.5625 that appears pretty much in every calculation of the bounce. So, let me pull that out. So, I copied this easeOutBounce function, and I replaced it with myEaseOutBounce. And I grabbed the constant here, and I put that into this value constant. It was set to 7, and I changed that one to 11 just to change it up a little bit. And let's see what kind of effect this has on the animation. So, that looks the same. I think we need to update our HTML code. Yeah. So, on our HtmlPage we have to make sure we're calling myEaseOutBounce. So, now it wildly goes past the end and bounces into place. Let's see it again. And maybe that's what you want. To me this looks a little bit more interesting. Let me tame it down a little bit. I'll make it instead of 11, let's just make it 9. And now we have a nice effect. I mean it overshoots a little bit and kind of bounces by overshooting and settles into its final position. So, all of these constants seem to be arbitrary, especially the S value, which will be undefined in JavaScript it seems for the easeInBack. So, go ahead and play with these values and see what you get, and you can easily adjust any of these functions. You just need to copy it and give it your own name. If you really want to look into these functions in detail, there's a comment up on top which tells you exactly what the parameters are. T is the current time, B is the begInnIng value, C is the change In value, and D is the duration. And another thing you could always do is just set a breakpoint. Like let me set a breakpoint here. And we can examine the values this way, right in the middle of all the functions running. So, you don't really have to understand fully what the algorithm is here. You can just know that you know this if statements look kind of like bounces. So, if you wanted to add more bounces, you could find a way to do that. And when you have something that seems like a constant, you can play around with that too just to see if you get a different effect. So, that's how you can add your own custom easings.

Summary

In this module, we looked at the many different easings we can get access to in jQuery. We looked beyond the linear and swing easing functions built into jQuery and looked at jQuery UI's many easing functions. We also saw how to use a jQuery plugin for easing functions so that we can avoid using the entire jQuery UI package. We wrapped up the module by copying and modifying some easing functions to put our own unique touch on some existing easing functions.

Advanced jQuery Animation

Introduction

This module is titled Advanced jQuery Animation. We'll be looking at a wide range of jQuery animation methods, options, and techniques. Probably the most valuable part of this module is learning how to animate non-numeric CSS properties. This allows us to take advantage of 2D and 3D rotations and other operations such as animating colors. We'll first look at transforming DOM elements in two dimensions. We'll be mostly interested in the CSS transform property. This property will let us translate, scale, and rotate any DOM element. Next, we'll look at 3D rotations on DOM elements. This also uses the CSS transform property. Internet Explorer 10 is the first IE release to support the CSS properties which make 3D animation possible. So, now all the modern popular browsers are capable of animation with 3D rotations. We'll look at animating colors with the jQuery color plugin. We'll take a look at working with animation queues. An animation queue holds animation commands, which will be executed one after the other. We've already seen this when we chained animation calls to create a complex animation. We can actually create several animation queues and have them simultaneously influence a DOM object. This would be useful in a case where we want to apply some kind of fade out or resizing of an animation, which is already running. Finally, we'll look at promises as they relate to animation. A promise is an object, which will let us know when an animation has completed or if an animation was prevented from completing.

Transforming DOM Elements in 2D

Let's take a look at transforming DOM elements in 2D. When we say transforming, we're referring to the CSS transform property and the various functions that can get called to move, scale, or rotate a DOM element. We'll look at a few of these transforming functions in this video. Up until now, we've only been animating numeric CSS properties such as an element's width and height, but animating an element's transform property is a bit more complex since it requires using CSS functions. The first CSS transform function we'll look at is translate. Translate simply means to move a DOM element to a new X and Y coordinate. Here we have an animated shape being translated down and to the right. There's another CSS transform function called scale. To scale an element means to make it bigger or smaller in the X and/or Y direction. This animated rectangle is being scaled in both the X and Y directions so that it's twice as big as the original. Another CSS transform function is rotate. Here we can see a star being rotated 360 degrees over 5 seconds. To modify the CSS transform property, we would set the property to something like this. We're setting the transform property so that the DOM element moves 100 pixels to the right and 100 pixels down. We're also scaling the element so that it's twice as big in the X and Y directions. Finally, we're rotating the DOM element 30 degrees. Now, we don't need to specify all three of these CSS functions to set the transform property. We could use only one of these functions if needed. Now, let's take a look at how we can animate this transform property with jQuery. So, I opened up the project, and we're looking at the m4-v2 for module 4 video 2 before. And this is our starting point for working with transforms in 2D. So, let's just run this and take a look at what it does. So, this is displaying the Pluralsight logo, and that's all it's doing right now. And let's take a look at the code just so we understand it. We're loading in Bootstrap in case we need it. We have jQuery and jquery.easing. Our image is right here, and we give it an ID of logo. And we're setting up a style for logo. We're placing it absolutely at 300, 100. And if you look at our script section at the bottom, we're just setting a variable logo to make it a little bit easier to work with down here. So, let's write some code to translate this image. So, let's take a look at this code I added. Starting here, we're calling the jQuery function, and instead of passing it the DOM object logo, we're passing it a dummy object. This is a simple plain jQuery object, and we're setting T to 0, and we're calling the jQuery animate method on that object. So, you have to make sure we're not calling animate on the DOM object, but rather on our own object. And the reason for this is that we want to animate a non-numeric CSS value. So, T is going to go from 0 to 200. This is our first parameter, and we're setting T to 200 so the animate method will know we're going from 0 to 200. And looking at our options to the animate method, the duration is going to be 3 seconds for the entire animation and our step option, if you remember, this is going to get called as the animation progresses. Each step of the animation when the screen is ready to refresh, this function will get called, and it'll pass it now, which will be in this case the value of T since we're moving T from 0 up to 200. And within this function, this is where we actually look at our DOM element logo and we call the jQuery CSS method on it. And if you're not familiar with the CSS method, basically that just lets you set a CSS property. So, we're setting the transform property, and we're setting it to translate 0 pixels and then now pixels. So, now will be the value of T from 0 to 200. So, essentially what this line is doing is we're moving it from its current position at, well the current position is up here 300, 100, but we're going to be moving it not at all in the X direction, and we're moving it from 0 to 200 in the Y direction. So, the image will be seen to drop down, and let's run this. And the image drops down as we expected, and it drops down 200 pixels from right here. So, the important thing to remember is that this CSS property is a function call. It's not a numeric value. So, when we're animating a CSS property that's not numeric, we need to make sure we pass it an object and not the DOM object, and this will keep track of whatever numerical value we are animating so that we can use it in a function such as this. So, besides translate, let's look at scaling the image. Now, I modified the code so that now we're calling the scale function. And we're setting T equal to 0 at the start, and we're having T progress from 0 up to 4 over the course of 3 seconds. And scale will take two numbers, how much it'll scale in the X direction and how much it'll scale in the Y direction. So, they're both going to scale equally here. So, for scaling, 1 is the original size, and we're starting at 0, which means it's very small. It's invisible. And when it reaches 1, it'll be the normal size, but we're going up to 4, so that means it'll be 4 times the normal size. And let's watch this animation. So, it started really super small, and it grew up to be 4 times the size. So, this image was drawn at a much lower resolution. That's why it's looking blurry here. But if you wanted to get rid of the blurriness, you would just have your artist draw it at the largest size, and then when it shrinks down, the browser is usually pretty good at making it look good in smaller resolutions, but in larger resolutions, the browser makes it look blurry. And let's look at a rotate too. So, I modified this line to call rotate, and we're setting it to now and degrees. We just want to make sure our parentheses match up there. And we're setting T is going to start at 0, and it's going to go up to 360. So, essentially what this is going to do is it's going to rotate the image from 0 to 360 degrees. Let's watch this. And we have our animation. So, what happens if we want to animate more than just one value? Here we're animating T, but what if we wanted to you know rotate, scale, or transform, but we wanted to use different values other than T? I'll modify the code to show you how that's done. So, let's look at this new code. First of all I'm creating two variables. S stands for scale and R stands for rotate, and we're setting those to 0 to start with. And here we have our object that we're going to animate over, and the scale is going to go from 0 to 2, and the rotate is going to go from 0 to 360, and the duration is going to be 3 seconds, and for our step function we're going to pass it an extra fx parameter. So, the now is going to be either S from 0 to 2 or R from 0 to 360. And the way we can tell is by looking at this fx. There's an fx.prop for property, and we're going to check if it's equal to S. So if we're scaling, we're going to set our S variable to now, but if we're rotating, we're going to set our rotate variable to now. And then down when we call our CSS method with the transform property we're going to scale it to S, and we're going to rotate it to R. So, what this is going to do is it's going to scale it from 0 to 2 from invisible to twice its size, and it's going to rotate it 360 degrees while it's scaling it. So, let's watch this. And we get our animation. I'll Refresh it. So, that's how you animate two different values at the same time. And you might just want to make sure you have storage saved off for those because when you get into your step option, the function for the step option, you're going to need to differentiate between which property is actually being animated.

Animating 3D Rotations

Animating DOM elements by rotating them in 3D is very similar to working with the 2D transform CSS property. You're probably used to using 2D space with an X and Y coordinate. The Y axis is a vertical line, and the X axis is horizontal. In 3D space we have a Z axis, which points directly at the viewer. Rotating an element on the X axis is accomplished with the rotateX CSS function, and it looks like this. Notice that we pass the rotation degree to each function. We could also specify rad for radiance if we're not working in degrees. Rotating an element on the Y axis is done with rotateY, and it looks like this. Rotating an element on the Z axis is done with rotateZ as we see here. This is very similar to rotating in 2D space. To animate 3D rotations, we need to update the CSS transform property just like we did with the 2D transforms. In this example, we're rotating 30 degrees on the X axis, 45 degrees on the Y axis, and 170 degrees on the Z axis. Let's take a look at how we can work this out in jQuery. So, in our sample project we're looking at module 4, video 3, before. Now, this is code that is very similar to the previous one except we're doing a rotation on the X axis in 3D. Let's see how it looks. So, that's doing a full rotation, 360 degrees all the way around the X axis. So, you can see it looks upsidedown when it gets halfway through the turn. So, when it's facing the other direction, we can still see through it. It just shows upsidedown. So, let's see how we did this. One of the key differences when we're working in 3D is we need to take the element that we're rotating, this image, and put it inside some other container. Here we're putting it inside a div, and we're giving that div an ID called box. And if we look up at our styling here, we have our styling for the box, and the position is relative. That lets us place the logo, which is absolute, directly inside the box, which is relative. And we set a left and top property and a width and height. And the key thing to remember here is that we need to wrap our element inside some other element in order to get the 3D to work. The next thing you need to do when working in 3D is to set up some CSS properties. Here we're taking the box, and we're setting perspective to 50 pixels. Perspective is a 3D value, which lets us know how close or how far away we are from the object itself, and the perspective-origin, this will let us center the image in the middle of our view or we can adjust this and get it to rotate from an edge, but we'll take a look at this a little bit later. So, the important things to remember when working in 3D are to have your bounding box, a bounding div or some other DOM element, and setting up your perspective on that box. And from there we can see we're doing an animation similar to the last video. We're creating an object with an R property set to 0, and R stands for rotation, and that'll go from 0 to 360 over the span of 5 seconds. We have our step function, and we're going to take the logo and set the CSS property transform to rotateX. That lets us rotate around the X axis. And now is passed into our step function, which will be the number of degrees. And that's how we get our rotation around the X axis. To make it more interesting, we could always add some easing in there too. Let's try it with an easeOutBounce. And we can speed that up a bit too. Let's do it over 2 seconds. Alright, now let's try it with the rotateY around the Y axis. There we get a big rotation where it really comes at us, so I'll do that again. Alright, so let's take a look at our perspective. We're very close to the object, so let's move farther away. I'll move it to 450. And now you can see it. We're much farther away, and it doesn't have nearly as dramatic an effect. Let's set it something closer to 150. And that might be a little bit better depending upon how you like it. I'll set that back to 50, and let's do a rotation around the Z axis. Alright. Now, we can also combine these rotations into a single rotation. I'll add the code for that. So, I added this code here. Now we're going to rotate around the Z axis, the X axis, and the Y axis, and we're going to pass it now into each one of these CSS functions. I'm also rotating from -20 up to 0. So, let's see how this looks. And there we go. If we did a full circle, it just gets a little bit out of hand. Let me try that, 0 to 360. And I'll Refresh it. Yeah, it just looks a little bit hyper, but if I was putting something on my website I would probably go with a smaller setting. That looks good. So, that's how you rotate in 3D space. The important things to remember are your surrounding box and setting the perspective and the perspective-origin. Now, I've been running these on IE 10, which can handle all this. Most of the other modern browsers can handle it too. But if you're working on Internet Explorer 9 or earlier, most likely these aren't going to work. It's only in IE 10 where it started supporting the CSS values. Let's just try and make sure that this works in Chrome. Yep, and that works fine too. One other thing we can notice when we're working with CSS is if we specify transform down here. Probably what you've seen before is something like webkit-transform or some vendor prefix, but jQuery takes care of that for us, and we just need to specify the CSS value without the prefix to get it to run.

Animating Colors

Let's take a look at animating colors. Here we're at the m4-v4-before.html file. And if we look at this, it's similar to our other projects. We're just displaying a logo, and we're attempting to call animate on the logo, and we're going to pass it a background color of red. It's going to turn the background red over 5 seconds. Now, this isn't a numeric value, so it shouldn't work. I'll run it, and nothing is happening, like the background isn't turning red at all. So, luckily in order to animate this, even though it's not numeric, we can get a plugin. We can get the jQuery color plugin. So, I'm at GitHub here, and there's a project called jquery-color. And you can get the plug-in here and read and read the documentation about it here. But for now since I'm using Visual Studio, the Express edition, I'm going to right-click on the project and go to NuGet, Manage NuGet Packages, and search for jquery color. And you can see that I already have jQuery Color added to the project. So, what I'll do is I'll go into Scripts, and I'll grab the minified version of it and drop it into the project. And now we'll run it again. And now we can see the background turning red over 5 seconds. I'll Refresh it again, and it's working fine now. So, by adding this plugin, jquery.color, we get access to the actual CSS color names. Without the plugin it won't work because it needs some kind of numeric value. If we look at the website again, there's actually a lot you can do with this plugin. You can see different ways of specifying colors like on the web with the hash tag or the rgb or rgb alpha. You can even extract different colors with getters and setters. Check this out if you're interested in doing more than just using the color name.

Animation Queues

Let's look at what animation queues are. In an earlier video, we saw how we could chain jQuery animation methods together to create a long-running animation. In this sample chain of calls, we're showing a DOM element, then calling three different animate methods on it, and then hiding it. jQuery queues up these calls and executes them one after the other. The queue that jQuery uses to hold these method calls is named fx. Fx is the default queue, and we don't have to specify it at all. But what happens if we want to apply a whole new series of animations to a DOM element while a previous animation is already running? Maybe we want to fade out the DOM element while it's still animating, or maybe we want to change colors, shrink it down, or perform any other type of jQuery animation. The solution involves creating a new animation queue. Here we're calling the animation queue myQueue, and we're calling animate three times. The only thing we need to do in order to make this happen is specify the name myQueue when calling animate. Let's take a look at the code which accomplishes this. So, we're in the sample project, and we're looking at m4-v5-before, module 4, video 5. And we have our logo, it's an image, and we're chaining some animations on it right here. We're going to show the image over the span of 3 seconds. Then we're going to animate the left property. We're going to move it to 300, and that's going to be over 2 seconds. Then we're going to animate the top, so it's going to move downward 200 pixels over 2 seconds. Then it's going to animate back to the 0 X position or left position over 2 seconds, and then it's going to hide for 3 seconds. Let's just run this and see how it looks. Now, all of this is running in the animation queue called fx. That's the default queue. And it'll hide. And that's the end of the animation. So, what if during this animation we decide we want it to have it perform some other animation, some other operation? For instance, let's get it to fade. First off I'll add a button, and we'll make sure that we have some way to make it fade within the middle of the fx animation. So, I added this button here, and it just says Fade Out. And when we click this button, you can see down at the bottom we're just grabbing the input. There's only one input on the page, so we're just grabbing that, and we're going to handle the click event. And what we're going to do is we're going to take our logo and we're going to call fadeOut, which is an animation method for jQuery. We're going to fade out over the duration of 2 seconds. And here's where we specify the option of a queue, and we call the queue myFade. So, if we were doing this with the animate method or some other animation method, normally we would just leave out this queue option, but since we want these two animations to happen together, the first animation being this, and the second animation being this fadeOut, we need to make sure we specify the queue. Now, it's important that after we put something in a queue we kick the queue off. And the way to start a queue is to call dequeue. So, we take our DOM element and call dequeue, and we pass it the name of our queue that we're using, myFade. So, let's run this. And right in the middle of the animation I'll hit the Fade Out button now, and it starts fading out while it continues the previous animation. Let's see that again. I'll Refresh it. Now the first animation is running, and then I'll click Fade Out now, and it starts fading out while the original animation still plays. So, to get that to happen, we have to use our custom queue, and you always have to remember to call dequeue to start it off. If we leave this out, nothing will work. I'll run it again. And no matter how many times I hit Fade Out now just nothing is going to happen. Its property adding those commands to the queue, but it just never kicks off. So, make sure you dequeue in order to get it to kick off.

Promises for Animation

Promises are very popular in jQuery when it comes to asynchronous network communication. If we need to grab some data off a server, we don't want our webpage or application to hang up while waiting for data. By using promises, we can be notified asynchronously when a network operation succeeds or fails. This mechanism can be used for animation as well. While a DOM element is being animated, we can think of it as an asynchronous operation similar to a network call. We don't know when an animation might end, but we may need to be notified if it completes successfully or if it was somehow interrupted. jQuery's animate method gives us three options, which work with promises. The done option specifies a function to be called when an animation completes successfully. The fail option specifies a function to be called when an animation is stopped and doesn't complete. The always option specifies a function to be executed when an animation either ends successfully or it gets stopped somehow. If we ever want to work with the promise object directly, we can chain a call to the jQuery promise method. Let's see how we can work with this in code. We're looking at the file m4-v6-before, and we pretty much have our standard setup. We have a logo right here, and we're going to animate the logo. We're going to move it right 400 pixels from 0 to a left value of 400, and we're going to do it over 3 seconds. And here you can see the done option. Now, the done option specifies a function that's going to get called when the animation has completed. So, when the promise is resolved and everything is good, we'll get this alert that says in done. Let's run it. And it moves to the right, the animation finishes, and we get our message. So, that's pretty simple. Now let's take a look at what happens if the animation gets stopped somehow. I'm going to add some code for that. So, I added a button up here with the input tag, and down below at the bottom we're going to handle the click event, and we're going to call logo.stop. So, this will enable us to stop the animation before it's had time to complete, and this alert should not fire. So, let's see this. And we'll Stop It. And the alert doesn't show up, so our done is not getting called. But what will get called is our fail handler. So, I added the fail option, and we're specifying a function that says alert with the word failure. Let's try that. And I'll Stop It. And we do get our failure, and we don't get our done. And we also have an always option, so let me add that. So, I added always, and we're going to alert with always. Now, always is always going to get called. Whether it's successful or a failure, always will get called. So, let's try it out. And I'll Stop It. We get our failure, and we get our always. And I'll Refresh it. We'll play it again. We'll let it run through to completion. And we got our done, and we got our always. So, I pulled up the jQuery documentation for animate, and here's the options right here. And these are the ones we just looked at, done, fail, and always. If you want, you can get access to the Promise itself as a first argument here. And the second argument is jumpToEnd. And this just lets us know if when it finished or when it stopped if it jumped to the end of the animation or not. Another useful jQuery method is the promise method. Let's take a look at that. So, with promise, we can get access to the promise itself, and that gives us a lot more opportunities to work with the promise just like you would with network communications.

Summary

In this module, we saw how to animate DOM elements by modifying non-numeric CSS properties. This allowed us to animate 2D transformations and 3D rotations. We also saw the jquery-color plugin, which allowed us to modify the color values of DOM elements. We worked with animation queues to see how we could apply a whole new set of animation methods to an existing animation, and we looked at how jQuery uses promises to give us feedback when our animations complete or get cancelled.

Creating an Animated Button

Introduction

This module is titled Creating an Animated Button. So far in this course we've looked at dozens of jQuery methods and animation options. We've seen them in sample code, but now it's time to start focusing on practical applications. This is the first of four modules where we'll be building animation projects and wrapping them up as reusable JavaScript modules for use in other projects. This module is dedicated to building the animated button you see here. It's a Buy Now button, and we'll be adding several animations to the text, shopping cart icon, and the entire button itself. I got the shopping cart icon from Font Awesome, and we'll look at importing that package for icons. You'll notice a radial gradient, which animates across the red background. This is used to draw attention to the button. When we enter the button with our mouse cursor, the button grows larger, and the icon and text grow even more. When the mouse leaves the button, everything bounces back into its original position. You'll notice we're using an elastic easing to give it that bouncing look. When we click on the button, a few animations take place. The text fades out, the button rotates 20 degrees, and the shopping cart rolls down the button and bounces against the right side while the entire button fades out. So, the shopping cart slamming into the side of your button may not be something you really want on your website, but this is a course in jQuery animation, and I'm a video game programmer, so anything with wheels is fair game for a collision. This button is created in modular, reusable code, so it's a great starting point for animated buttons or other animated components in your own website.

Project Setup

So, let's get started building our Buy Now button. I have a project here BuyNowButton_All_Demos, and we'll go to the BuyNowButton-v2 for video number 2. Now, in the before folder I set up some basic files. If we look at our HTML file, it doesn't have anything in it really, but it's got the framework. If we look at our CSS file, it's completely blank, and if you look at our JS file that's also completely blank. Now the first thing I'm going to do is I'm just going to right-click on our HTML file and just make sure that's our start page. Next we're going to need to add jQuery. So, I'll go up to the project and Manage NuGet Packages, and jQuery usually comes up first. Make we go to the Online. I'll Install jQuery, and I'll Install the easing, jQuery Easing. So, now let's drag and drop everything into our project. We'll take our jQuery minified version and drop that, we'll take our easing file, and we'll also take our own CSS file and put that on top. Usually the link comes first. And we'll take our JavaScript file and put that last since it relies on jQuery. So, next I'll enter some code for our button. So, I created a div, and I'm giving it an ID of btn for button. And inside the div we're putting a span for our text. And we're closing it off, and let's just run this. Okay, so everything seemed to execute fine. We have our BUY NOW! And the next thing we'll do is make it look like a button. We'll go to the CSS file, and I'll paste some CSS code in here. Okay, so I entered some CSS markup, and if we look at our body, we're setting the font-family to something sans serif whether it's whether it's Helvetica, Arial, or just sans. We're taking our font-size, setting that to 25 pixels, and the text color will be white. Next we're taking our button. We're using a hash tag, so looking back at the HTML we are setting the ID to button. So, an ID requires a hash tag in CSS. And our button is going to be positioned absolutely, so we're setting that to absolute just in case we want to animate it and move it around. We're setting the left and top to 150 each just to get it away from the borders. The background-color is red. The width and height are set. We're setting a border-radius of 12 pixels. That'll give us rounded corners. And we're setting a border, which is 6 pixels solid blue. And then we're going to create a drop shadow for it. We're going to use the box-shadow tag or property, and we're going to set it to be offset by 5 pixels in the right and lower position, and we'll set the color to gray. So, let's see how this looks. Alright, so now it's starting to look a little more like a button. Let's add some CSS markup for our text. So, I added a new CSS selector. We're going to look at the button, and we're going to grab its span tag. If you look back at the HTML code, you can see the span tag inside the button, so there's no reason to give it an ID. We can just access it with this selector here. And we're going to position it absolute. That way we can animate this separately from the button itself. Top: 50%. That'll center the text within the button. And we're going to set margins, and we're going to make it bold, font-weight: bold. Alright, so now we have our text, and we're leaving some room over here for the shopping cart icon, which we'll add later. So, there's one more thing to do to get setup, and that's to start working with jQuery a little bit. Let's grab our JS file. We want to be able to reuse this code. We want to be able to create our own namespace and make sure we don't add a whole bunch of code to the global scope, so we'll use a common pattern for this, and I'll paste it in here. Alright, so let's take a look at what we're doing here. First of all, we have a self-executing function here, an anonymous self-executing function. It's anonymous because it has no name, and it executes because we're passing it a parameter within these parentheses here. So, what we're doing is we're creating a namespace called PS for Pluralsight, and we're attaching it to our main window. And we're setting that equal to either itself if it exists or we're going to set it to just a blank object. And that way we can use this namespace in many different files and not have to worry too much about the order in which the files are listed in our HTML file. So, we're passing this function our namespace, and then we use that namespace to create our object or our class, which is BuyNowButton. We set that to a function, and now we have a nice closure that will keep things out of the global namespace. And you'll also notice we're passing the function our ID, which will be the ID of the div that we're going to use for the button. So, I'll Save this, and let's go back to our HTML file. So, we're going to have to new-up one of these buttons, so I'll enter the code for that. So, I added a script tag, and inside the tag what we're going to do is instantiate our BuyNowButton. We're going to look at jQuery's DOM ready function. We're going to pass the function here, which will execute when the DOM is loaded, and we're going to set a variable called B, and we're going to new-up a Pluralsight.BuyNowButton. And remember we have to pass it btn, which is our ID. So, this shouldn't do much, but let's just run it and make sure it works. Okay, so we have our button. It doesn't do anything yet. It's not animated, but at least we're all set up.

Using Font Awesome for Icons

This is the Font Awesome website, and we can use Font Awesome to put our shopping cart icon within our button. If you're not familiar with Font Awesome, basically what it does is it lets you add all kinds of icons of all different sizes and styles. Let me click on the Icons link, and we can see some of them here. These are the new icons, Web Application Icons, but what we're interested in is the shopping cart. Let me try to find that here. It's right here, icon-shopping-cart, and this is what we want to add to our button. Now, it's probably overkill to include the whole Font Awesome library just for that one icon, but instead of the icon you could just use your own image or, you know, consider using Font Awesome and add icons to your whole site. Now, we know we want the shopping cart icon, so let's see how we include that. I'll click on the Examples link, and here we can see how to use inline icons. We use the I tag, we specify the class, and we'll put icon-shopping-cart, and we end off the tag. If we look a little lower, we can see we have different sizes to play with. We can do an icon-large to increase it by 33% or we can do an icon-2x, 3x, and 4x. And here's a good example of what they look like enlarged. Now, to download Font Awesome, you can just go to the home page and there's a big download button, but since I'm using Visual Studio Express, I can just do it through NuGet, and I'll do it that way. I'll go to Manage NuGet packages, and we'll search for font awesome, make sure we're Online here, and I'll Install it. And that'll put that in our Content folder. So, I'll grab the minimized version and put that on top because it's a CSS file. Next we'll add the icon to our button. I'll put the I tag right here. Alright, so we have our I tag with the icon-shopping-cart, and let's see how it looks. Okay, so we got our shopping cart. We need to resize it and adjust it a bit. Let's go with that class we saw on the website. It was icon-large. Let's see how that makes it look. Okay, so that's better. The size is better. Now we just need to use some CSS to put it in place. I'll go to the CSS file, and we'll add a button I for the I tag, and I'll populate this with some properties. So, I added position: absolute. That'll let us animate and use this icon without it having being tied to the button or to the span, and we'll just set the position to 20 and 8. I'll run it. And there we go. We've got our Font Awesome icon in place.

Animating A Radial Gradient

Next we're going to look at putting the highlight feature into the button. This is going to be a radial gradient that sweeps across the background, and it should be very subtle, and it shouldn't distract too much, but the technology we're going to use is a radial gradient. So, here we are at gradientcss.com, and I clicked on the Radial Gradient link here. And I don't want to get too much into the syntax of it, but you can definitely read about the syntax here, and you can see the browser support. You can see that Internet Explorer hasn't supported it until recently with version 10. And also on something like Firefox it required the moz vendor prefix until Firefox 16.0+ in which case we don't need it any more. But it looks like Chrome still needs a webkit and Safari still needs the webkit, so we'll just use jQuery, and that'll automatically append the vendor prefix for us. But the thing to keep in mind is that if you're using Internet Explorer before 10.0 it's probably not going to work. So, going down a bit and looking at the examples, this is the general syntax we're going to use right here. We have a background for our button, and we want this radial gradient to sweep from one end to all the way across to the other end. So, the syntax looks like we use the background property in CSS and we set it to this radial-gradient function. And we're going to pass it circle at coordinates and then the two colors, the middle and the outside of it. So, let's go to our HTML code. So, in Visual Studio or whatever your HTML editor is, I'm going to go to this BuyNowButton video 4 and pull up the, in the before folder, pull up the HTML. Let's just make sure this is set up right. Okay, so there's our button, and we want the radial gradient to start off the left side and animate all the way across very subtly to the right side, and we'll have that loop every so often. Now the way we'll get this to execute is going to be within the JavaScript. So, let's pull up that file. And I'll add some code for that. So, I added this code here. We're going to call setInterval, which is a timing function, and it's going to call this first parameter function every 3000 milliseconds or every 3 seconds. So, let's look at this anonymous function here. What we're going to do is we're going to animate. We're going to use the jQuery object and pass it a plain object. We're going to animate the X value of the gradient from -30, and we're going to have it animate up to an X value of 260. And that'll start it off the left side and push it off the right side. And the reason we can't directly animate a radial gradient is because it's not a numeric value. We're going to have to call the CSS function for radial-gradient. So, looking at our options, the duration is going to be 2 seconds, and the step is going to get called for every frame, and it's going to be passed now, which will be our X value. And what we're going to do is we're going to take our button B, which we'll set up on top. So, we'll set our variable B to be the actual ID with the hash tag for jQuery. So, that will be our jQuery object, and we'll change the CSS value background to our radial-gradient CSS function. So, we're going to do a circle with a radius or a diameter of 80 pixels at now, and now is going to be our X value, and the Y value is going to be 30. And the inside of the radial-gradient will be something close to pink or kind of like a whitish on the red side a little bit, and it's going to go to red, which is the color of our button. So, that's what will give it a blend in effect with our background. So, let's run this and see what we get. We have to wait 3 seconds for the interval to set off, and it goes straight across. It looks like it's sticking on the end a bit. We need to push it off the edge a little bit more. So, let's do that. I'll just change the X value to 300. We'll wait 3 seconds, and there it goes. And it's off the edge pretty much. That looks good. So, we probably don't want to leave this at 3. Let's bump it up to 8 seconds. That way we don't have to watch it the whole time, and it won't be too distracting. Now, let's try this in some different browsers just to make sure they're working fine. I'll go to Firefox, and I should set the interval back to 2 or 3, but yeah that looks good. I'll set it to 2 for now, and let's try it in Chrome. And that looks good too. So, I'll set this back to 8 seconds. And the thing you want to remember is that when you are working with a radial-gradient here, it is kind of new to these browsers like it wasn't supported in Internet Explorer until version 10, so you really want to check it out and make sure everything is okay on the different browsers.

Animating mouseenter and mouseleave Events

So, in the last video we put in our first animation, which is the radial-gradient sweeping across the background. So, next we're going to look at handling the mouseenter and the mouseleave events. That way when we mouse over it we can have some kind of animation occur, and when the mouse leaves the area without clicking a different animation can play. So, I'll paste in code for that. So, I pasted in the code starting here, like this whole section. Let's take a look at what it does. It calls button. Our B variable is our button, and we call the jQuery method hover, and we pass it a function. Now, hover accepts two functions. The first function is on mouseenter when the mouse enters into the button, and the second function is when the mouse leaves the button, which we'll implement soon. But let's take a look at the mouseenter. We call our jQuery function, and we pass it a plain object. So, we're going to animate a scale, and we're going to animate the scale from 1 to 1 dot 1, 1.1, so it's a 10% increase in the size. The duration is going to be 1 second, the easing will be easeOutElastic. That'll give it a little bit of bounce at the end. And we're going to call the step option. We're going to pass it a function, which will modify the CSS value transform on the button, and we're going to set the scale to now. And we're also going to transform the children of the button, which would be the span and the I tag, the shopping cart image. And we're going to set the transform property to scale, and they're going to scale up a little bit more. We're going to multiply now by 1.1, so that'll make the text and the icon a little bit bigger than the button itself. So, let's run this and see this animation by moving the mouse over the button. So, notice the size of the font and the icon right now. And then when we mouse over, it increases with a little bounce, and we still have our little flare going across the background. So, now when we mouse out, I'll add the code so that it'll go back to normal. On a mouseleave event, we're going to do the opposite. We're going to scale it from 1.1 down to 1, we'll leave the duration at 1 second, it'll be elastic as well, and we're just going to scale it down to now, which will be 1 at the final point. And we're going to scale both the button itself and all its children. Let me fix this here. And I'll run it. So, now we get our mouse over or our mouseenter and our mouseleave are working fine. So, in jQuery when you need to work with events such as mouseenter and mouseleave, it's a lot easier just to use the hover method.

Animating The Click Event

So, we have our mouseenter and mouseleave events working fine. Let's handle the click event next. So, I'm in BuyNowButton video 6, and I'll go to the HTML file. Let's just make sure that that's our start page, and we should probably look at the JavaScript. Below the hover handler, I'll add some code here. So, I added a click handler to the button. We call the jQuery click method, and we pass it our handler function. The first thing we're going to do is we're going to fade the text inside the button. We're going to find our span, and we're going to fade it out over half a second. Next we're going to tilt the entire button. We're going to pass jQuery our plain object, so it'll be an animation that goes from tilt to 0 animated to tilt 20, and this will be the number of degrees. It starts off at 0 degrees and will tilt it down and to the right 20 degrees, and we'll do that over 1 second. And our step function will accept a parameter called tilt, which happens to be the same parameter we're using in our object. It doesn't need to be, but it could be. And then we're going to change our button's CSS value transform. And we're going to rotate it by tilt degrees, and this happens on a click. So, let's try this out. So, our text faded out, and it rotated clockwise 20 degrees. If I continue to click on it, we still get that motion with the text still faded out, so let's fix that. So, once we get our click, we need to disable the click, and we should also disable the mouse in and mouse out or the mouseenter and mouseleave events as well. So, I added this one line of code. What we're going to do is we're going to take our button, our jQuery object button, and unbind the three events that we're handling now. We're handling mouseenter and mouseleave with the hover method up here, and this is our click handler, so we'll remove that as well too. So, let's run it now. I'll click on it, and now mouse over, mouseenter and mouseleave, and our clicks have no effect. So, the next thing we want to do is have our shopping cart roll down the button and slam against the wall. Let's do that. Alright, so right after we fade the text, I'll paste some code. This is where we move the shopping cart. We take our button and we find the I tag, which is our shopping cart, and we're going to animate it. We're going to animate the left property from its current position to 235. And the way I came up with this 235 was to try it and see how it worked. I mean I guess I could've calculated the size of the button itself and the size of the icon and adjusted it, but it was just easiest to eyeball it and come up with this number. And I'm going to do an easeOutBounce, and that's what makes it bounce against the side of the button. And all of this is going to happen over 2 seconds. So, let's check it out now. So, I'll click, and our shopping cart rolls down the button and slams into the side. It looks good. Try it again. Alright.

Adding A Callback for The Click Event

So, we're in BuyNowButton video 7, and let's just make sure our HTML file is set as the start page. So, the button is pretty much working now. This is what we want. There are a few things we need to do to clean it up. One is we need to fade this out towards the end, and we can also fade it in at the beginning. Like if I Refresh it, it shows up, which if fine, but we can add a little bit of animation at the beginning as well. So, let's start with that. So, when we kick off the BuyNowButton, instead of calling setInterval right away, let's actually fade it in. I'll add the code for that. Alright, so we still have our setInterval, and this code is all the same, but I wrapped it in a fadeIn. We're going to call fadeIn on our button, and it's slowly going to fade in. And when it's completed, this is our completed function, which will kick off the interval. So, in our CSS file we'll go to the button selector, and we'll set display equal to none. And let's try it out. So, now we get a good fade in. I'll Refresh it. Yeah, we can see it fading in now. Now, also we want it to fade out, probably while it's bouncing against the edge. So, let's add code for that. We're in our JavaScript file, and looking at our tilt animation here, we can just do it at the end of this, so I'll add code for that. So, I added the complete option, and it's just a function that's going to fadeOut the button over 1 second. So, let's see how this looks. I'll click it, and we get our fade out. It looks good. I'll Refresh it, and we can see it again. Click. Alright, so there's one more thing I wanted to add, and that's like we don't really know when the button gets clicked in our original code. We know it gets clicked here within our object, but we need to send a signal back to the caller that the button was clicked so that we can do something. So, let's go back to our HTML code, and what we'll do is we'll also pass it not just the ID, but we'll pass a callback function. Okay, so our callback function is going to give an alert button clicked. And we'll go into the JavaScript code, and we'll pass it the callback here, and we'll just hold onto that. I'll actually call it CB. So, we have our callback set, and after the click when the fadeOut completes we'll add the function here. So, I added this code to fadeOut. It's going to fade out over 1 second, and then the complete handler is right here. In our complete handler, all we're going to do is call the callback function that we stored up on top. So, let's run this. We've got the button, we click it, the shopping cart does its thing, and we get our button clicked alert. So, now this code is pretty modular. We can give it our own namespace, and we can pass it a callback that'll get called when the button is clicked. And let's just see it all one more time. I'll run it. We have the animation of the background gradient going across. That should show up every 8 seconds or so. There it is. And we have a mouseenter and mouseleave event, and we're using the jQuery hover method for that. And you can see the text grows a little bit as it bounces in. And a click will tilt it and do our shopping cart animation, and it fades out, and we get a callback to our original calling function.

Summary

In this module, we created a modular Buy Now button. We saw how to use Font Awesome, and we made use of the shopping cart icon. We handled the mouseenter, mouseleave, and click events, animating each one. We used jQuery's fadeIn, fadeOut, and animate methods to put our button and shopping cart in motion. We packaged our button in a namespace and modularized it giving us a good starting point to create more animated buttons and DOM elements.

Creating an Animated Picture Gallery

Introduction

Welcome to the module Creating an Animated Picture Gallery. In this module, we're going to use jQuery to create the picture gallery you see here. These pictures are illustrations of the 12 zodiac signs, but you can use any image files for this project. In this module, we'll put together this gallery piece by piece making heavy use of jQuery's animation features. The JavaScript file for this gallery ended up being only 180 lines of code, so it really shows off the power of jQuery for use in animation projects. We'll go over loading and displaying images. We'll use jQuery's hover method to attach animations to the mouseenter and mouseleave events. You'll notice when I mouse over an image all the other images slowly move away from it. Then when I mouse out, all the images move back into place. When I click an image, the image zooms in while all the other images rotate in 3D and fade out. When I click the image again, all the images animate back to their original positions. We'll use Internet Explorer, Firefox, and Chrome to test out our gallery. 3D transformations still have some quirky behavior in modern browsers, and Internet Explorer hasn't even allowed for standard 3D transformations until IE 10, its most recent version. We'll look into problems with the various browsers and either fix them up or find ways to work around them. This gallery is written as a reusable module, so you'll be able to easily make changes to it for use in your own projects. Now, let's get started.

Project Setup

So, let's get started building our gallery. I have a gallery project here for the source code, and if we look at Gallery-v2 for video 2 we can go into the before folder, and let's make sure our Gallery.html is set as our start page. And looking at this HTML file, it's a blank file for now. Also, we have a Gallery.js for the JavaScript, and we have a GalleryStyles.css, and I populated this with a little bit of CSS script right here. So, let's go into our Gallery.html, and I'll add a tag for the gallery itself. So, I added a div with an ID of gallery. And then when we look at our CSS, we can see that we're doing a hash for the ID, for gallery, and let's take these up one by one. The position is relative because our images are going to need to move within this gallery, so we're setting relative as the position. The left and top properties are set to 8 pixels just to have some margin. The background-color is dark gray. The border is 2 pixels solid black, and we're setting a width and height, and we're setting some 3D parameters, and these will be used later. We won't need these for now, but just remember that they're in there. So, let's go back to our HTML file, and we'll take our GalleryStyle.css. We'll add that to our project. We also need to go to NuGet. We'll go to the Manage NuGet Packages menu, go Online, and we're going to have to add jQuery and also the jQuery Easings. And those are in Scripts, and we'll just take the minified version of jQuery. We'll add that, and we'll take the easing and add that. And we'll also take our own JavaScript file and add that. Okay, now we can run it. And here we have our gallery. It's a simple rectangle, and we'll place our images inside it. For the images, I placed those in our Images folder, and they're numbered 01 through 12. And we'll get these loaded up and showing in the next video.

Loading and Displaying Images

So, we're in the folder Gallery-v3 for video 3, and we're looking at the before folder. And let's take a look at Gallery.js. I added some code to this. This is the same pattern that we saw in the Button Module. What we're going to do is we're going to create a namespace called PS for Pluralsight, attach it to our window, and we'll just make sure this namespace gets used throughout the function. It gets passed up here, and then we use that namespace to create our Gallery class. When we new-up this class, we'll pass it the ID, and the first thing we'll do is we'll create a variable called gallery, and we'll set that to our jQuery object, the hash tag for the ID, and then the ID itself. And the reason I like to do this is it's good to have it around because we're going to be using it often in this code. So, we have the basis of our JavaScript set up. Let's go back to our HTML. So, let's new-up one of these objects. So, we're creating a variable G, and that's going to be our gallery. We're newing up a PS.Gallery, and we're passing it gallery as the ID. So, everything will be placed within this div right here. Now, we still need to get our images into the gallery, and instead of creating HTML, let's just make a loop and read them in that way. I'll paste the code for that. Alright, so I pasted this code right here. If we look at our Images, we can see that they're numbered 01 through 12. So, what we're doing is we're going to wait for the DOM to be ready with our jQuery function right here, and we're going to execute this. We're going to loop from 1 through 12 for the image names, and we're going to append a .png to each one. And if it's less than 10, we're going to need to prepend it with a 0 because it begins with a 01, not just 1. Next, we're going to create a jQuery object called img, and with jQuery we can just pass it a new DOM element. We're creating an image with a class of galleryImage, and we're setting the source equal to Images, our Images folder, and the name that we created up above. So, once we have our jQuery object, it doesn't really exist in the DOM yet. We need to append it to the gallery. So, here we grab our gallery, and we append the image. Now, just because we appended the image doesn't necessarily mean that the image loaded yet. So, in a later video in this module, we'll go over how to make sure that the images load before we start using them, but for now it's going to be fine with our browser. So, I'll run this. And we can still see the outline of our gallery, and all the images are full size here. And there's no real formatting or CSS applied to them yet, so they're just all dumped out. So, let's fix that up. Let's go to our JavaScript file, Gallery.js, and let's start getting these images into place. I'll paste some code. Alright, so I fixed up the code a bit, and let's look at each file. We'll start with Gallery.html, make sure it's the start page. And before this line where we new-up, our gallery was outside of the document ready function, and that's not going to work. It needs to be after all these images get loaded, so that's the first fix I made. Next we can look at the CSS, and I added a selector for galleryImage. Every image in the gallery is going to be assigned this class, and we set the position to absolute. This way the image is free to move around the gallery itself, and we create a border, a 1 pixel solid black border. Now, the bulk of the code I just added is in Gallery.js, and I added this code here. The first thing I did was I created an images variable, and this is just a convenience variable so I don't have to call gallery.find to get all the gallery images. So, this will save us some time because we're going to be using it a lot. Next, we want to start working with positioning all the images within the gallery. So, we're going to start at coordinates 50 and 50 for our X position and our Y position. Then we're also going to grab the gallery width. We'll call that gWidth. So, we've got some variables set up. Now we want to loop through all our images. We take our images set, and for each, each is a jQuery method that's going to loop through all the images. So, for each one we're going to call this function, and this function will get passed two arguments, an index and the element. Now, the element that gets passed in, this is common in jQuery. It doesn't usually pass a jQuery element. It passes the DOM element, so we need to wrap it up. I assign that to image. The next thing is we start working with our image data. If you're not familiar with the data method for jQuery, what it does is it lets you maintain key value pairs that get assigned to a DOM element, and this is really useful. It helps us so that we don't have to create a new object and store all of these variables somewhere else. So, we're going to set the homeX value to the X position and the homeY value to the Y position. So, the image is going to know its X/Y coordinates. It's going to know the place where it belongs in the gallery. Then we set the currentScale to 1, and that's also within the data. Now, just because we're setting data doesn't mean we're doing anything with CSS yet, so we also have to take our CSS and set the left to the X position and set the top to the Y position and set our width. We take the img.width, and we're only taking 25% of the image width because the image is pretty big. So, after we set up the coordinates for the first image, we need to adjust our X position. So, we want to put the X position to the right by 95 pixels, and this is just to check to see if we go over the right edge. If we go over the right edge, then we'll reset our X position to 50 like it was set up here, and we'll take our Y position and we'll just go down a line, about 115 pixels. So, let's run this. And there we have our images. The first one is placed here, and they go to the right, and then when it reaches the end it'll loop back and draw the second row on the bottom. Now, this isn't very dynamic. It's kind of locked into the images that I have by doing this, and it also limits us to pretty much the images that we're working with here, 01 through 12. You're probably going to want to use something like this with your own images, so feel free to modify all this or better yet make it dynamic so that it can read your images and get their widths and heights and fit things automatically without you having to go adjust these values all the time. But for now it's looking good, and we're ready to start our animation.

Mousing Over Images

Alright, so we're in the project, and I'm at Gallery video 4 in the before folder, and let's take a look at the Gallery.js. Or actually, let's just run it and see what we have. Okay, so this is where we left off. We have all our images. Now, the next thing I want to do is I want to be able to roll over the image, like have the mouseenter event fire and have the image get bigger, and then when the mouse leaves the image will go back to its original size. And if you watched the Buy Now Button Module, you know that we can do that with the hover method, so let's take a look at doing that. We have the jQuery code, and I'll paste code for hover. So, I added the hover method. We're calling img.hover, and we're doing this within the closure up here so we have access to our image variable. So, if you remember, the hover method takes two functions. The first function is for mouseenter, and the second function is for mouseleave. Looking at mouseenter, the first thing we need is we need to look at the event parameter, and that'll tell us which image is being targeted. Now, this event.target needs to be wrapped, so we wrap it in a jQuery object, and we set it to target. Then the next line I created a function, which we'll see soon, but it's called animateImage. And we're going animate the target, which we just set here. It's going to be for half a second, and we're going to animate it to its home. Now, it should already be placed in its home, but later on we're going to to see that it might not necessarily be in its home X and Y coordinate, so we're going to make sure it goes to its homeX and homeY position, and then we're going to scale it to 2 so it'll be twice as big as the original thumbnail image looks. And we can also see when we mouse out it'll call a function returnAllToNormal. So, let's take a look at these two functions, animateImage and returnAllToNormal. We'll take a look at animateImage first, and it's right here below it. So, we pass it the image; the duration of the animation; the left and top values, X and Y values; and the scale. The first thing we do is we stop any animation that currently exists on this DOM element. The next thing we do is we're going to use a dummy CSS property. We don't have any text, and the textIndent property is totally useless, but we're going to be using this for our scaling, and you can see down here I put a comment in use textIndent css property for scaling. And we're going to set textIndent to the currentScale. And now we can call animate directly on the DOM object. In the previous module with the button that we created, we used custom objects, like we didn't really animate the DOM object directly. Instead we would just instead of using a technique like a dummy CSS value, we would just create a dummy object. However, we can't do that here, and the main reason why is that in order to make things smooth, we're going to need to be able to stop any animation. And if we're using a plain object and animating a plain object instead of the image, we're not going to be able to stop it unless we dig deep into the internals of jQuery, and I'm just not going to go there. So, instead we're going to use this textIndent to handle our scale, and we're going to animate the left property and the top property, and we're going to animate the scale. So, in our options for the animate method, we're going to set the duration to the passed in duration up here, and then our step is going to be a function that's going to handle these three different properties, left, top, and textIndent. So, if it's textIndent we're going to scale, and we take that scale value now, and we assign it to our current scale in our data. And we also have to set our CSS. We'll set the transform property equal to scale and the now value. If we're working with the left property, then we simply set left to now, and if we're working with the top property, we set top to now. So, this convenience function, animateImage, is going to take care of our animate jQuery call for us. All we need to do is pass in the image, the duration, the left, top, and scale. So, looking back at our hover, we call it here, but then also when we hover out with a mouseleave event, we call returnAllToNormal. And let's look at that. In returnAllToNormal, we're going to loop through each image, and we're going to call this function. We're going to take the element and wrap it and call it image, and then we're going to call animateImage again. We're going to take that image and over half a second we're going to set it back to its homeX and homeY coordinates, and we're going to scale it back to 1. So, this is going to loop through every image everywhere in the whole gallery and make sure that it's home and it's set back to a scale of 1. Let's run this code. So, I'll mouse over and mouse out, and we get our animation. Now there's obviously a problem with the z-index, like this should be showing in front of the Cancer here. Gemini should be on top, and yeah it looks like that's the case all the way across. So, let's look at fixing that with the z-index. So, I added some code. If you're not familiar with the z-index, that just tells you what's on top like which DOM elements get drawn on top of which other DOM elements. And the higher the value of the z-index, that's the element that's going to be placed on top. So, looking at our hover, our first function in, I'm calling a function bringImageToTop, and we're passing it target. And if we scroll down a bit, we see it right here. So, looking at bringImageToTop it accepts the image, and we're going to loop through all the images. And for each image, basically we're going to take the element, and we're going to set the z-index to 0. And then for the image that we're passing in we're going to set the z-index to 1. So, with all the z-indexes at 0, that way we can make sure that the image we're passing in goes on top. So, let's run it now. So, that's fixed. Whenever we mouse over an image it goes on top of everything else around it. So, in the next video we're going to work on getting these images to move away from the selected image. Like you can see the overlap. Like it overlaps the images on the sides, but it would be a pretty cool effect if we can get those to slide away a little bit.

Animating Images Away from The Mouse

So, in the Gallery_Project I'll go to the folder Gallery-v5, and we'll go to the before folder and make sure we have Gallery.html set up as our start page. And we'll run this. So, what we want to do now is we have our mouseenter and mouseleave events working, but when we select an image we want all the images on the left to move to the left and all the images on the right to move to the right a little bit. I think that'll be a cool effect. And also the images below it should shift down, and the images above it should shift up. So, let's do this. I'll open up our JS file. And looking at our hover method call here, we can add it right in here. Right after we bring the target image to the top, we'll move everything else out of the way. So, I'll add the code for that. I added this line, avoidImage, and we're passing it the target. This is going to have all the images in the gallery avoid the target image, so let's take a look at this function. It's right here. So, we pass it the target that we want to avoid, and we we're going to loop through all of our images with the jQuery each method. This function will get called, and the first thing we do is we grab the element and we'll wrap it as a jQuery object. Next, we want to compare the image and make sure that it's not equal to the target. We can't really compare the jQuery wrapped objects because we're creating a new one here, so what we do is we grab the 0 element, which will be the actual DOM element, and we can compare those two. So, as long as we're not working with the target element, we can execute this code. I'll just take this comment out. So, the first thing we do is we grab the xdiff, and it's the difference between the image and the target image. And we're looking at the homeX key that's stored in the data for the image. And we also grab the ydiff. Next, what we want to do is we want to adjust the image. So, to adjust it in the X direction, we'll just set it to this adjust value, which is currently set to 40, or we'll set it to the negative value. Or if it has the same X value, we'll just set it to 0. And we do the exact same thing with the yAdjust. We'll adjust it by 40 or -40 depending upon the position relative to the target. And if we are adjusting the Y position here we say well we're not going to adjust the X position because we're on a different line. So, we have our xAdjust and our yAdjust, and we want to add that down here. We'll create a variable called newX, and we'll grab our homeX value and add the xAdjust. And we do the same for newY. We grab our homeY position, which is its position within the gallery, and we'll add the yAdjust. So, now that we have our newX and newY variables set up, we can animate the image. We'll animate the image for half a second and setting it to the newX and the newY position and a scale of 1. So, while the target is increasing in size, we'll make sure the scale is 1 on all of the other images. So, let's run this. So, now we can see when we mouse over all of the images move away. The images to the right move to the right. The images to the left move to the left. And depending upon if we're up or down, the other lines just move away. So, one problem with this is if we move rapidly between the images you can see the bottom line here is bouncing up and down. It's a little bit jagged. And the reason that is because we have a little gap here in between our images. So, what we want to do is when the mouse goes over that gap we want to ignore it for a short amount of time. So, I'll add in the code for that, and we'll get rid of these jagged motions. So, I modified the code slightly. We're at the top of our Gallery.js file, and I added a variable called hoverWait, and I'm setting it to false. What hoverWait will do is this is the wait period that tells us okay we moused out of an object and we're going to wait for a short amount of time to see if we're actually going to go over another object, but if we don't then we'll animate back to normal. So, this hoverWait is used down here in our mouseleave event. We're leaving an image with the mouse, so we set the Wait to true, and then we're going to set a timeout. We're going to wait 200 milliseconds or one-fifth of a second. And if that time passes and we're still waiting, then we're going to return everything to normal. Before, this function only contained this one line, but now we have this mechanism where we're only going to execute this if the mouse is out and it hasn't gone over something else. So, if you look at our mouseenter event, the first thing we do is we set hoverWait equal to false. We're not going to be waiting anymore. We moused over something else, so we can just cancel out of this timer. And right here is where the check is done. So, this is just a small mechanism just to make sure that as we mouse over things remain smooth. So, let's run this. Now, when I sweep across the side everything goes smooth. We don't see the bottom line bouncing up and down a little bit. However, if we do go slowly and we wait our one-fifth of a second we do get that slow motion, and that's fine. It's when we move fast then it looks jerky. That's what the problem was. So in the next video we're going to work on clicking an image and getting it to zoom in.

Zooming In on A Click Event

So, we're in the Gallery_Project video 6, and I'll just make sure we set the start page properly. And let's run it. So, the gallery is looking good. Let's make it so that when you click on an image the image zooms and fill up most of the gallery. So, we're going to need to handle the mouse click event for that. We'll go to the JavaScript code, and we have our hover right here, and below that we'll put a click handler. So, I added this click handler right here. The first thing I did was we have this variable now called showingLargeImage, and we set that to false at the beginning. So, if we're not showing the large image, we want to show the large image. So, we set the variable to true, and we animate the image. We want to animate the image over half a second, and we're setting it to coordinates 200, 150, and we want to make it four times the original size. And then if we're not showing the large image, this will execute. It'll animate the image back to its home position, homeX and homeY, with a scale of 1, and we're going to return everything else to normal. And finally, we make sure that we're not showing the large image anymore by setting it to false. Another thing I had to do was while we are showing the large image we want to disable our hover events, so I just check and see if we're showing it, and I'll just return if we are showing the large image. That way we have to click on the image to get it back to normal. So, let's run this. I'll click on the image. So, now we get our large version of it, and I positioned over here to the left a little bit in case you wanted to add some text or something on right, but that's just an arbitrary location for it. And if I click it again it'll go back to normal. So, I think also on the mouseleave I also had to do the same thing. When you leave an image you just want to make sure that we're not showing the large image. It's only on the click that we have a handler for the large image that's showing. So, in the next video we need to, when we do zoom into an image like this, we need to have everything else go away in the background.

Background Images Rotate and Fade Away

So, we're in Gallery-v7, the before folder, and I'll make sure our HTML is ready to go. I'll run it. Okay, so when we select an image now, I want the background images to go away. I'll have them fade out and rotate in 3D. So, we'll go to the JavaScript code. And looking at our click event, if we're going to show the large image, this is where we want them to fade and rotate away. And then when we're done showing the large image, we're going to return everything to normal, but they're still going to be faded out, and they still might be rotated in the wrong direction. So, I'll just put a comment in here. So, this is where we'll put the code to fade the images back in and rotate them back to normal. So, I'll paste this code now. So, I added some code starting here, and I'll make some room. So, when we want to fade and rotate the images away, we need to loop through our images with our each method, and we'll grab the element and wrap it up as the target. We'll compare the target to the image that we're looking at right now, which is the image being clicked. And if they're not equal, then it's not the selected image, so we need to animate it. We're going to take the target and animate it down to an opacity of 0. We're going to do that over the duration of 1 second. And not only are we going to animate the opacity, but we're also going to use that same opacity value from 1 down to 0 to do a rotateY. So, we're going to transform this element rotating it around the Y axis, and it's going to rotate 90 degrees, and we just use this construct because our opacity is going from 1 to 0, and this is what lets us rotate in degrees. So, at the beginning now will be 1 in which case this will evaluate to 0, and by the end of the loop now will be 0 so it'll be -90. So, this is going to rotate from 0 to -90. So, this takes care of the case where we're zooming into a large image. And then when we zoom out of the large image, we'll execute this. So, again, we're looping through the images, we set our target, we make sure the target is not equal to the image that it zoomed in, and then we animate the opacity back to 1. So, it should be at 0, and now it's going up to 1. We're doing that over the duration of half a second, and we're setting our transform. We're going to rotateY in the exact same way, but now we'll be going from -90 to 0. Now, another thing I had to do was I commented out our returnAllToNormal, and I placed that right in here. So, this is our complete function. When everything is rotated back, if we're still showing the large image, we want to return everything to normal, and this will only execute once because we're setting showingLargeImage to false right away. So, even though we have 12 images or so that are animating, this will only get executed once because of this flag. And I also had a comment showingLargeImage. I had to comment this out down below. So, let's run it. I'll select an image, and all the other images rotate out and fade away. I'll click on it again, and they all come back. So, that looks good. The only problem is we get these artifacts on the edges. If you look over here, you can see them over here and in this area. And I'm not really sure what that is. I know they don't show up in Firefox. Let's run it in Firefox. And yeah everything is pretty smooth over here. So, I don't know if it's a problem with Internet Explorer or the video card, but if that was really a problem most likely what you would have to do is just not use this 3D rotation. You could use just the fade in or fade out or do some other operation here with CSS that doesn't involve 3D. So, looking at this again in Internet Explorer, for the most part everything is looking good. We can click on our images. Everything moves smoothly. We'll try to get rid of those artifacts in the next video, and we also have a problem with loading images some times. Like if you noticed with Firefox the images didn't load right away, so we'll fix that in the next video too.

Fixing Browser Specific Problems

So, there are a few things I want to clean up. First of all, let's go back to the previous project. I'll go to Gallery-v7, and I'll go to Gallery.html. Let's just make sure the browser is set to Chrome, and we'll take a look at Gallery.html, View in Browser. Now, you can see that the images didn't load. They've been loading fine in Internet Explorer, but in Chrome they're just not loading, and that's our fault. Like if we look at our HTML, we're appending the images, but we're not really waiting for the image to load before we show it. For whatever reason, Internet Explorer is able to deal with that, but Chrome and Firefox, sometimes they're not. So, let's go to the Gallery-v8 for this video, video 8, and I'll set the Gallery.html as our start page. And you can see the fix I made in here for the image loading. I create a variable called loadCount and set it 0, and then after we do our append, all this is code we've seen before, we take our image, and we call the load method. And this is going to execute this function here when the image is actually loaded. So, when the image actually gets loaded we'll increment our loadCount, and when it's equal to 12 we'll new-up our PS.Gallery. So, in Chrome let's run this now. And we can see everything ran fine. The images loaded, and we're good to go. Now, there's another problem with Chrome. When we select an image it gets blurry. No matter which ones we select, it's going to get blurry when it's zoomed in. So, I looked into this because it's not happening in Internet Explorer, and it's not happening in Firefox, and it comes down to this line of code right here where we're rotating Y. If we comment this out, and this is in our fade and rotate away section, so this is where we rotate all of the back images, not the image we're selecting, but all the other images on the Y axis. So, if we comment that out and run it, we can see the images fade out, and we don't get a blurry image. Let me try a few more. Yeah, it's not blurry at all. It looks fine. So, I looked into this, and the best I could find is it's a problem with the browser. If we uncomment that, we can rotate it around the Z axis. That would be a regular 2D rotation, and that works fine. So, all the other images are rotating 90 degrees, and we still get our clear image. But as soon as we do something with the X or Y rotation, I'll rotate in the X, then we get our blurry image again. So, this isn't so much an animation problem. It's more a CSS-type issue or a browser issue. It also could have something to do down below with the z-index. I played around with that for a bit, and it was able to fix some things, but not everything. But the key thing to keep in mind if you do run into these kinds of troubles with the different browsers, you should probably get away from the 3D rotations because the 3D rotations are kind of new and their reliant somewhat on video cards or they're just new features within the browsers. So, commenting this out, it still looks like a pretty decent app. Even though everything is fading, it still looks pretty cool. Now, the last thing I want to look at is the CSS file. I'll click on the GalleryStyles.css. And if we look at our 3D properties here, perspective and perspective-origin, you can see we're getting an error for 250px, and it ends up that it doesn't like the PX. So, the error goes away, but when we run this in Internet Explorer, if you notice, the background images go away. They don't rotate with any perspective. They do rotate, but the 3D perspective is gone. So, if we add the PX back in there, we get our error, and we also get our perspective back. Another problem with this is that if we run it in Chrome, like we know we had that blurry problem that we saw before, but you'll notice there's no perspective in Chrome. And the reason why is that looking at our CSS perspective isn't valid in Chrome. We need to put a vendor prefix on it. So, instead of duplicating it here with vendor prefixes, I'll just comment it out, and we'll go to the Gallery.js, and I added this code here. So, now after we set our gallery variable at the beginning of the function, we'll also set the CSS here. And what jQuery does is it'll add any vendor prefixes for us, so that's great. And if we run this now in Google Chrome, you'll see that we do get the 3D perspective. So, the key thing to keep in mind is that when you use CSS with jQuery you are getting some benefit, like it is going to add vendor prefixes for you.

Summary

In this module, we created an animated picture gallery using jQuery and its animation features. We saw how to load images properly so they'll display in all browsers. We animated images on the mouseenter and mouseleave events by using jQuery's hover method. We handled the click event in jQuery to zoom into the image while the other images rotated in 3D while fading out. We saw the problems of animating 3D CSS properties and how they don't always work consistently in different browsers, and we saw how we could still leave out the 3D features to create an attractive gallery.

Creating an Animated Pie Chart

Introduction

Welcome to the module Creating an Animated Pie Chart. Up until now, we've been animating existing image files as DOM elements, but sometimes you'll need to animate images which you draw yourself in JavaScript. Here's the pie chart control that we're going to be creating in this module. Each slice of the pie chart is drawn using JavaScript in its own HTML 5 canvas element. We let the user select a slice with the mouse, and then we have the selected slice rotate to the top of the pie chart and separate from the rest of the control. This animation is a little bit more complex than the previous projects where we built an animated button and an animated picture gallery, so we're going to create a simple state machine to help us organize the various animation states our pie chart moves through. Determining which pie slice gets selected involves the use of angles measured in radians. So, we'll cover what radians are and how they're used in circles and rotations. We'll also integrate and animate DOM elements along with our pie chart to show the title and percentage of the selected pie slice. At the end of this module, you'll have a modular pie chart control that you can modify to suit the needs of your own projects.

Project Setup

I already set up the project to start with so we can go to AnimatedPieChart_All_Demos, open up the AnimatedPieChart_02 folder, and then go to the before folder. And let's take a look at PieChart.html. I already set up our style sheet, PieChart.css. We're using jQuery, and we're using jquery.easing, and we also have a script for the PieChart.js. And we'll take a look at the CSS file and the JavaScript file in a second. Let's just go through this first. So, the only real element we have is this div right here, and it has an ID of pieChart, so this is going to hold our pie chart. And we have a script tag at the bottom, and this function is going to execute when the DOM is ready. So, looking at this function, we create a variable called data, and it's an array, and it has three plain objects in it. Looking down a bit, the title of the pie chart is going to be Smartphone Market Share. So, we divided up the data into three sections, iOS with 20%, Android with 67%, and Others with 13%. The other thing we add in the plain object is the color, and this will be the color that the pie slice gets rendered in. Now, normally you would be getting this data from some kind of AJAX service or web service, but for now we're just going to hard code this, and we're going to create our pie chart down here. We're going to new-up a PS.PieChart; we're going to pass it the ID pieChart, which matches our DOM element ID; and we're going to set the title Smartphone Market Share; and we're going to pass in our data object. So, the HTML file is all set up to go. Let's look at the CSS file quickly. We have our ID of pieChart set up. The position is relative. This is so that we can place the pie slices and any other objects inside of it. We're setting up a margin just to move it away from the edge of the browser. We're setting a border to 1 pixel solid lightgray. The width is 300 pixels. The height is 500 pixels. And the font-family, we're just setting it to a sans-serif font, whether it's Helvetica, Arial, or whatever is on your system for sans-serif. And finally, looking at the JavaScript file, we have the same pattern we've seen before. It's a function, an anonymous function that's self-executing. It executes down here by passing it the PS namespace for Pluralsight. And you can see ns becomes our namespace. We're going to attach the PieChart to our namespace. So, all of our code will be within this function right here. And the first thing we do is we just create a variable called pieChart, and that'll be our jQuery object. So, we're all set up to go. The only thing we'll be able to see is the styling, the CSS, which put the light gray border around our rectangle for the pie chart.

Drawing The Pie Chart

Alright, so now we're going to draw the pie chart. We're going to draw each slice individually. So, let's go to AnimatedPieChart_03 in the before folder, and I'm going to right-click on PieChart.html and make sure that that's set up as the start page. Okay, so I added some code to draw the pie chart slices. Let's take a look. So, we're in PieChart.js, and originally it stopped right here at this line, and I added some variables. We're going to hold an array of slices. We're going to hold the centerX and centerY. That'll be the position of the pie chart and the radius of the pie chart. Then I created a function called createSlices, which I call down here. And let's take a look at how createSlices works. We initialize slices to an empty array, and we have a start angle of 0. Now, we're going to be drawing on the HTML 5 canvas, so let's take a look at a slide that shows how angles work in canvases. So, here's a circle that could be our pie chart. And normally we deal in degrees, but the canvas and a lot of math functions like to work in radians. So, let's just look at what a radian is. First of all, angles start going directly to the right at 0 radians, and they proceed clockwise. So, what would normally be 90 degrees would be pi over 2 radians. And then 180 degrees would be pi radians. And then 270 degrees would be straight up, and that would be 3 pi over 2 radians. And then when we go full circle, instead of going to 360 degrees, it's 2 pi. So, it's important to always remember that we are working in radians and not degrees. So, back at the source code we can see that the startAngle is being set to 0. So, that's going to be straight over to the right side of the circle. Next we're going to loop through our data that was passed into the function, and we're just going to set the variable slice equal to the data with the correct index. And we're going to push that slice into our slices array, which we declared up here. So, I'll hide this pane. The next thing we do is we set a canvas property on the slice, and in jQuery we can just create a tag with the normal jQuery function. We're going to create a canvas, and we're going to give it a class of pieSlice, a width of 300 pixels, and a height of 300 pixels, and we'll close out the canvas tag. So, this is going to create a DOM element, which is a canvas, but it's not going to attach it at all to the DOM. Down here is where it gets attached. The pieChart will have appended to it our slice.canvas. So, now that we have a canvas attached to the pieChart, let's draw the slice. We set the variable C to the actual DOM element. We take our jQuery canvas, and we grab element 0, which will be the actual DOM element for it. And we'll get the context for the canvas and set that to the context variable. And then we can start drawing our slice. We begin to draw a path and we move to the center of the pie chart, centerX and centerY, which were set up here on top. Next we draw an arc in our canvas. We start at the center, and then we reach out to radius, which we have set to 100, and our startAngle, initially our startAngle is going to be set to 0 as it was set up here. And then we calculate our ending angle, which is this big calculation right here. And then we pass it false for counterclockwise. We want to go clockwise. So, basically what this is doing is we're taking our startAngle, and we need to calculate the end angle. So, it's the startAngle plus the percentage of the slice divided by 100. If we look back at our data in our HTML file, you can see that the percentage is listed as a regular integer. It's not a decimal, so we're going to have to divide that by 100 to get the actual percentage. So, here's where we get the actual percentage, and we multiply that by pi times 2, which as we saw in the slides is a full circle. So, this whole equation right here is going to give us our ending angle, and that'll draw an arc from the startAngle to the end angle. And next we want to do a lineTo to draw a line back to the center of the pie chart. Now, we're going to fill that pie slice with slice.color. If we look back at our HTML file, you can see that we are passing the color into each array element. Once we set the fill style, we can actually fill the pie slice, but then we want to stroke it. So, we'll set a lineWidth to 1, we'll set the strokeStyle to black, and we'll stroke that same path that we already created. Now, we're going to be looping through each slice, so we want to make sure that we reset the startAngle. And we reset the startAngle with the same equation that we used up here. So, the end angle for the previous slice becomes the starting angle for the next slice. Now, an interesting thing that we're doing is we're actually creating a canvas for each slice, and this will make the animation a lot easier. So, let's run this and see how it looks. Alright, so we have our first slice. It goes out to 0 radians to the right, and it draws it around this way, clockwise. And then our second slice is below that, and that's the big, I think, Android 67% slice. And then our other slice is, I think this was like the 13% slice for Other, other than iOS and Android. And we can just confirm that in our data. I'll go to the HTML file, and yeah the first one is iOS at 20%, then Android at 67%, and Other is at 13%. So, the obvious problem is these aren't laid our correctly. We need to have them all overlapping, and we do that in CSS. You'll notice in the JavaScript we add a class called pieSlice to the canvas. So, going to our CSS file, let's add a selector for that pieSlice right here. So, for our class we use a dot, so .pieSlice. We're going to set the position to absolute. That way we can position these slices exactly where we need them to be positioned. And we're setting the top to 200 pixels. So, not let's run it. And now all our three canvases are all overlapping, and that's good. So, nothing is happening yet. We just drew the slices. In the next video, we'll take a look at what it takes to actually select a slice.

Selecting A Pie Slice

So, I'm in AnimatedPieChart_04, the before folder, and I'll make sure the HTML file here is set to the start page. So, looking at the JavaScript file, we want to handle the click. When the user clicks on the pie chart, we want to be able to determine which slice was selected, and we do that starting right here. After we create our slice.canvas, we'll add a click handler to the canvas. So, this function will get called on every click, and we call a function called handlePieClick, which we'll see soon. It's down below. But we're going to pass this function two arguments. We're going to send it the offsetX of the event and the offsetY, and those will just be the X and Y coordinates of where we clicked inside of the canvas. So, let's look at handlePieClick down below. So, I added these two functions right here, handlePieClick and getAngleFromXY, and let's take a look at what they do. We pass it the X, Y, and the first thing we do is we get the angle from those X, Y coordinates. And let's take a look at a slide just to make sure we understand that. So, let's this is our pie chart, and the user clicks or touches right here. We need to get the angle to the middle of the circle. So, what we do is we drop a line from the point that's clicked to the X axis, and then that'll form a triangle, and it'll be a right triangle. The line that we're dropping to the X axis is perpendicular, so it's a right triangle. So, from this we're going to be able to calculate A and B, which are the two sides of a right triangle. And we know the length of both sides of a right triangle, you can use a special math function called arctangent to calculate this angle, and that's the angle we need to get. Once we know this angle, we'll be able to calculate which slice of the pie chart was selected. So, looking back at the code, let's take a look at getAngleFromXY, and that function is right here. So, we calculate our deltaY and our deltaX variables, and these are the A and B that we saw in the slide. Basically we just subtract the center from the Y coordinate that we clicked, and that'll get us our change in Y or deltaY as I call it here. And the same with the deltaX. We subtract centerX from X, and we get the change in X. So, now that we have deltaY and deltaX, we can pass those to Math's arctangent2 function, and that'll give us the number of radians in the angle. So, we're passing it the X and Y of where we clicked it, and we're returning the angle from the center of the pie chart. And if we look back up to where this is called, we'll store that angle in variable A. Now, sometimes A is going to be negative in which case we're going to have to add a full circle. So, 2 times pi is a full circle as we saw before, and we'll just add that to A. Now, this code gets a little bit complex, and I won't walk through it in too much detail, but the important thing to know is that okay we have our angle. Now we need to find out which slice was clicked, and the variable slice is going to be set at the end of this code here. Essentially what we do is we loop through all the slices, and we create a slice variable to hold that slice that we're currently looking at. And we have our first angle, and we set our last angle the same way we did up above. Like if you remember from the createSlices function, this is how we came up with the ending angle. We used this formula here, and we also used it up here. So, we have our first angle and our last angle. Then we just have some logic to determine if we've gone full circle and if we have a slice to select or not. But the important thing to know is that after this executes we have our slice variable set, and I'm putting up an alert that says selected, and we're going to show the title of the slice. So, let's run this and make sure that we do get slice set properly. So, we know our first slice is iOS, so selected iOS. We've got that. The big slice is Android. We've got that. And this other slice is Others, and that comes up fine. So, no matter where we click, it should work. I tried out all the corners and everything, and everything is looking good so we do know which slice is getting selected now.

Rotating The Pie Chart

So, now we're going to get the pie chart and all our slices to rotate. We'll go to AnimatedPieChart_05 and the before folder, make sure our HTML file is set up as the start page, and let's take a look at PieChart.js. If we go down to our handlePieClick function here, and I commented out the alert, and I added a little bit of more code here in order to get it to rotate, the first thing I do is I create a tAngle variable. So, the tAngle is going to be set to the top angle. That's the angle that the selected slice needs to be at in order to show on top. And the way we calculate that is we go 1.5 times pi. And if you remember, 3 over 2 is 1.5, and that's the angle which goes straight up in radians. And then we take our last angle and subtract the first angle to get the total size of this slice, and we divide it by two, and this whole thing gets subtracted from the top angle. So, tAngle gets set to the angle that our top slice needs to be at. Now, we're going to want to rotate to that tAngle, but we have to subtract the first angle. And then we set our destAngle equal to tAngle minus first, and that'll just give us the rotation that we need. If our destAngle is less than 0, we just want to normalize that and add a full circle to it, pi times 2. That way we'll make sure it's positive. So, at this point, destAngle is going to be set to the destination angle that we want to rotate to. So, we call a function called rotateSlices, and we pass it that destAngle. If we look up, I'll close out this function here, and we have our rotateSlices function right here. And this is where the animation takes place. We're going to create a plain object, and it's going to have one member, A, set to the currentRotationAngle, and that's another variable I added up on top. We're setting the currentRotationAngle equal to 0, and as the pie rotates, this angle will rotate as well, will change as well. So, we have this plain object and we're passing it into jQuery so that we can call the animate method on it. So, it's going to animate A from the currentRotationAngle to the destAngle, which we're passing in. And that's the basis of our rotation right there. We're going to do it over a duration of 800 milliseconds, and for each step of the animation we're going to call this function. And in this function we're going to loop through our slices, and for each slice we're going to grab the canvas, and we're going to set the CSS transform property to the rotation. So now is the parameter that gets passed right here, and that's going to be our A variable in our plain object. So, we're going to rotate to now radians. And the other thing I do is I take our rotation value now, and I put that in the data for the canvas. We need to hold onto this because later on we're going to use it, but you just need to know that the canvas is now going to have a key value pair on rotate which will tell us what that slice is rotated to. And then once this animation completes, we'll call this function, and we're going to set our currentRotationAngle to the destAngle that was passed in at the beginning. So, let's run this. We have our pie chart, and I'll click on the first slice, and it rotates so that it's straight up. And this is what I was talking about before. We want this slice to point straight up, so we have to take this straight up angle right here and subtract half of the width of that slice to come up with this angle. But now matter which slice we select now, it's going to rotate so that it's pointing straight up. Now, that rotation is fine, but I want to add some easing to it just to make it a little bit more interesting and bouncy. So, I added easing: 'easeInOutBack'. Now, let's take a look. Now we can see when we select a slice it's going to wind up a little bit and go into place, but it's going to overshoot a little bit and snap back. And I think that looks pretty good on a rotation animation. So, in the next video we don't just want to select a slice, but we want to have that slice pop up and out of the pie chart so we can get a better look at it, and we'll see how to do that in the next video.

Adding A State Machine

Now, the animation is getting a little complex. There are a few states we need to go through as we animate the pie chart, so let's look at each one of these states. The starting state is StateIdle, and that's the state where nothing is happening. We haven't clicked on a slice, and there's no separated slice, and just nothing is happening. There's no animation going on. The next state is StateRotating, and this is where we did click on something, and the pie chart is rotating into place. It's going to take our selected slice and point it straight up. Next is StateSeparating. We haven't coded this yet, but we're looking at the final project here. This is where the selected slice jumps out, and then after it completes jumping out we go to the next state called StateSeparated. This is where the selected slice is separated from the rest of the pie. And then when we click on that slice again, we go back to StateJoining, and that's where the slice joins up with the rest of the pie. Now, when we're in StateSeparated, you'll notice that we can still click another slice. If we do select another slice, then it's going to enter StateJoining, but immediately after StateJoining it's going to go to StateRotating so that it rotates again, and then it goes to StateSeparating to separate out the next slice and back to StateSeparated. So, the two main paths we need to be concerned with are when we have a separated slice we either click on that slice to close it or we click on another slice to close it and have that new slice open up. So, with these five states we can handle all of that, and let's take a look at the code. So, I'm in AnimatedPieChart_06, the before folder, and let's take a look at PieChart.js. I added this setState function right here. And you can see we pass it the newState, and we set our animationState variable equal to newState, and we declared our animationState variable right above it, and then we switch on the state. If it's StateIdle, most of this isn't filled out right now, but we set the isAnimating to false. If it's Rotating, we call our rotateSlices function that we in the previous video, and we pass it the targetAngle. TargetAngle is another variable that we created. And then for StateSeparating we don't do anything except we set isAnimating to true. For StateSeparated, we set isAnimating to false. This is the point where the separated slice isn't being animated. It's just showing on top. And then StateJoining we set isAnimating equal to true. So, having a simple state machine like this makes it pretty easy. If someone comes along to look at your code, they can just check out which case has a problem and go straight to the proper function. So, the next thing I did was at the very bottom of our function here after we create the slices I just make sure we set the state to idle, and that's one of the first things that happens. Also, if we look in our handlePieClick, before we were rotating the slices to the destAngle, but we're not going to do that anymore. We're going to set our new variable targetAngle to the destAngle, and then we're going to set the state to StateRotating. So, looking back at our state machine here again, we can see that StateRotating is going to call rotateSlices for us passing that targetAngle, which was declared up above. So, we're going to run this, and it should look the same as before. The only difference now is that it's being run by a state machine. So, in the next video we're going to fill out the rest of the states and get all the animation happening.

Animating The Selected Slice

So, now we're going to fill in all the states and make sure all of the animations are working properly. We'll go to AnimatedPieChart_07, the before folder, and we'll make sure PieChart.html is our start page. We'll take a look at the JavaScript file, and if we look at our state machine function, setState, we can see now before we had rotateSlices for StateRotating, and now we have separateSlice for StateSeparating, and we have joinSlice for StateJoining. So, let's look at rotateSlices first right here. So, in rotateSlices I added to the complete function, I added a setState StateSeparating. So, after we rotate, we need to separate the slice that we selected. So, going back to StateSeparating we call separateSlice. And looking at that function, here we do another animation. And we're going to use the textIndent property for animation because we're actually going to animate two things here. We're going to animate our top value to move the slice up, but we're also going to use the textIndent as a dummy value for scaling. So, textIndent will be our scale because there's no need for us to use the real textIndent CSS value because there's no text. So, the scale is going to go from 1 to 1.5, and the top is going to go to its current position to 100. It's going to separate the slice over 1 second, it's going to use an easing of easeOutElastic, that'll give it a nice bounce, and for our step function we're going to look and see if we have the textIndent property being set. Let me just make some more room here. And if we are setting the scale through textIndent, what we're going to do is we're going to take our selectedSlice's canvas and set the CSS property transform to rotate and scale. Now, we're only scaling here, but we need to include the rotate as well, and that's why if you remember earlier on we took the rotate value and we passed it into the date for the canvas. So, we're able to set our rotate from data we already knew, and we're able to set our scale from the now value, which is passed into the step function. And then once our slice is separated from the pie, our complete function will fire off and will set the state to StateSeparated. Looking at our state machine function, in StateSeparated nothing is going on except we're setting isAnimating to false. Now, let's look down at our click handler function again, handlePieClick. So, I added a little bit of code in here. This remains the same, and this is set up for a state machine more now. But after we get our slice variable set up so we know which slice is selected, we compare it to the selectedSlice. And if they're the same, then we just want that selected slice to fall back into the pie. So, we created a variable called nextSelectedSlice, and we just set that to null, and then we set the state to StateJoining. So, if we look at our StateJoining, we call joinSlice. Let's take a look at that function, and this is the last of our animation functions. So, basically we use the same textIndent property as a mechanism to handle the scaling from 1.5 back down to 1, and we're going to move the top position from 100 back to 200. It's going to animate over half a second, it's going to have an easeOutBounce so it'll bounce into place, and we do the same exact thing we did before like we set our transform for the canvas's CSS transform to rotate and to scale to the now value. Now, when we're done joining, there are two different paths we can take. If there's no nextSelectedSlice, then we're idle. We set the state to Idle. And there's no selected slice, so we null it out. But if there is a nextSelectedSlice, this is going to execute. We set our new selectedSlice to the nextSelectedSlice, we set our targetAngle to the nextTargetAngle, and we set our nextSelectedSlice to null. And now we need to rotate, so we set the state to Rotating. So, let's just run this and make sure we understand these two different paths. If I select this big slice, now it's separated out. So, if I click on it again, it just goes back into the pie. There's no more rotation, and there's no other selected slice. And that's the case right here. There was no nextSelectedSlice so we set the state to Idle. Now, if we select a slice, and instead of clicking that slice to make it go back, I'll click on this big Android slice to select that one. So, a few things happen there. First, this slice has to go back in, and then the big Android slice has to rotate and pop back out. So, let's see that again. And that all happens right here. Our nextSelectedSlice was selected down below, we'll see that in a second, and that becomes our new selectedSlice. And we set the angle, and we blank out the nextSelectedSlice, and it goes into StateRotating. So, down below we have this logic here. If our animationState is separated, then we're working under the assumption that the new slice that we selected is not equal to our selectedSlice. So, if we are separated, we set up our next slice, we set up our next angle, and we set the state to joining. This way the separated slice will join back in with our pie. But if we're not separated, then we must be idle. So, this is the case where idle happens. We set our selectedSlice to the slice, we set up our targetAngle, and we set the state to StateRotating. Now, when we're working with JavaScript and an HTML editor that lets you debug and have breakpoints, it makes it a little bit easier to understand this. So, let's just set a breakpoint up here where slice equals selectedSlice, and let me just run it from here. Now, if I select this, this is our selected slice. If I select this, we should hit the breakpoint, and we do. I'll Continue. But if we have a selected slice and I click some other slice such as this big Android slice now, we don't hit the breakpoint. In that case, it fell through down here to one of these two cases or one of these two conditions. So, feel free to use the debugger and go through the logic to make sure you understand how the state machine is working. Another thing I had to change was, the reason why we have this isAnimating variable is because we don't want to interrupt our animations. It just makes things a lot more complex if we have to start interrupting our states from completing and interrupting our animations from completing. So, if we look at our click event, or it's actually up here in our slice.canvas.click handler, we just check if we're animating. And if we are animating, we return. We don't even try to handle the pie chart click. We just get out of here and let the animation complete. So, when we run it, we can start clicking on stuff in the middle, and it's not going to interrupt the animations. And these animations are so short we probably don't want to interrupt them anyway. It just adds a lot of unnecessary logic to the code. Alright, so our animation is working fine. The next thing we're going to do to wrap this up is we're going to show the percentage of the slice when it's selected, and we're going to show some information about the selected slice.

Animating DOM Elements for The Selection

So, we're going to wrap up the pie chart by adding some information about the selected slice. I'll go to AnimatedPieChart_08, before, and set our PieChart.html as the start page, and let's pull up the JavaScript file, PieChart.js. I added this code here. What we're going to do is create a heading variable, and that's going to show on top of the pie chart. We create a div and the end tag for it. And inside the div we'll create an h3 for the title, which we pass in above, and an h4. The h4 tag, this will hold the information for the selected slice. And then we make sure that our heading variable is appended to the pieChart. And below that we're going to show the percentage of the selected slice. So, we create a variable called percentSpan, and that's just a span that has a class called percentSpan. And we're going to take that and append that to the pieChart. Then we're going to set some CSS values for the percentSpan. We set the left and top properties based upon our centerX and centerY, and we're going to give it a high z-index because we want to make sure it appears above all the slices, and we're going to make it invisible by setting the opacity to 0. So, when we select a slice, we're going to need to populate the description here in our h4 tag. Inside our span we're going to need to put the percentage from the slice. So, looking down below at our setState function, we do everything in here. When we're at StateSeparating, that's when we have a selected slice. So, we'll take our percentSpan and modify the text value, and we'll set it to the selectedSlice percentage, and we'll append the percent sign to it. We'll also take our heading, and we'll find our h4 tag, and we'll set the text to the title of the selectedSlice. And then once the slice is actually separated, we get StateSeparated. And we'll take our percentSpan, and we're going to animate it. We're going to animate the opacity from 0 to 1. But then after when the slice is no longer selected, we're going to animate the percentSpan from 1 back down to 0, so we'll hide it here. And we're also going to find our h4 tag in the heading, and we're going to make sure that text is blanked out. So, let's run it. I'll select a slice, and we can see immediately our h4 tag is populated with the description or the title of the slice. And after a slice is selected and the animation stops, the percentage fades in. So, let's just make sure it works on all our slices, and it's looking good.

Summary

In this module, we created an animated pie chart control. Instead of loading pre-rendered artwork, we drew our pie slices in HTML 5 canvases. We let the user click on a pie slice to have the slice rotate and pop out of the pie chart. We set up a state machine to handle our animation, and we also learned about circles and rotations and radians. You now have a starting point to build your own controls that may require custom drawings and canvases or require the use of a simple state machine for animation.

Building and Optimizing A Simple Sprite Engine

Introduction

Welcome to this module titled Building and Optimizing a Simple Sprite Engine. All of jQuery's animation methods work with some kind of duration or animation length. You need to know how long a DOM element will animate before you can kick it off. There are many cases where we're just not going to know the duration of an animation. We may need to animate objects dynamically based on user interaction or other factors. In this module, we'll be using jQuery to set up our DOM elements; however, we'll be using our own animation timer and loop to control our animated elements. A Spite is a visible object on the screen, and this term is usually used in video game programming. In a game, everything on the screen that moves could be considered a Sprite, but a Sprite can be used in more than just video games. If you wanted to create some cool special effects in an advertisement or you wanted to experiment with dynamic particles or other simulations, Sprites would be useful. We're going to create a simple Sprite engine that lets us easily create Sprites and set them in motion. Our Sprites will be displayed on a control that we'll call a GameSurface. Once we get our GameSurface operating, we'll take a look at optimizing our code. We'll use the profiler in the Chrome browser to take a look at our code in detail. We'll isolate the exact code which is slowing things down and fix it up to get better performance.

Setting up The Sprite Engine

Alright, so I put together a very simple Sprite engine, and let's take a look at it. First I'll make sure the SpriteEngine.html is our start page, and we'll run it. So, here we have what I'm calling a game canvas, and it's this rectangle right here with the light border. And inside of the game canvas we're going to be able to play Sprites, and this pinwheel is an example of a Sprite. So, this is going to be our framework and starting point to work with animation in jQuery using our own timer. So, taking a look at SpriteEngine.html, we have our own CSS file, and we're using jQuery, and we have our own JavaScript file. In the body we create a gameSurface. It's actually a div that's blank with an ID of gameSurface, and at the end we have a script to kick things off. So, what we're doing is we're handling the DOM ready event, and we set the variable surface to our new GameSurface. It's called PS.GameSurface, and we're passing it the gameSurface ID right here. So, once we have the surface, we need to put a Sprite on it. So, we create a Sprite next. We're going to call the Sprite S, and we create a new PS.Sprite, and we're passing it this image right here. If we look in our Images folder, you can see the pinwheel right here. So, once we have our Sprite, we call surface.addSprite, and we pass it S. And that's how we get our Sprite in the top left corner. So, quickly looking at the CSS, our gameSurface, it has pretty standard properties here. We set a margin, make sure the position is relative so that we can place Sprites inside of it anywhere, set up a border, a width, a height, and then overflow hidden. If you're not familiar with overflow, it just chops off anything outside the bounds of the element. So, if you have something scrolling outside the element it'll disappear. And then when we create a Sprite, we make sure the position is absolute, and for now we're just setting the width to 50 pixels. And then looking at our SpriteEngine.js file, if we go to the last line we can see we're doing our regular pattern. We're creating a namespace called PS for Pluralsight and attaching it at the window level, and we're passing this into an anonymous self-executing function, and we're calling it NS when we pass it. So, we're going to create two classes. I call them classes. They're not really classes. They're more like functions or closures, but basically we have one called Sprite, and we have one called GameSurface. So, looking at the Sprite, we pass it the image, which is the file name, and we'll create and image property, and that's just set to this DOM element, which is an image. Then we set an X property and a Y property to 0. We set an xSpeed to 0. I'll add a ySpeed in there too and then a loops flag if this Sprite is going to loop around the edge of the screen. And we don't really need this width here. I'll take this out. So, these are the basic properties we need for our Sprite. We need the image, X and Y coordinates within the GameSurface, and a speed in the X direction and a speed in a Y direction and whether or not it's going to loop. This is a Boolean flag. The only other thing is like when we create our image we set the class to sprite. That way when we look in our CSS file it will pick this up right here. So, back in SpriteEngine.js, we also are creating a GameSurface class or a function, and the properties include the surface itself, which is the jQuery object, and we're keeping an array of sprites. And we're going to be adding a timer, but we're not doing anything with that yet. And we add a function called addSprite, which we pass to the Sprite too, and we just simply push the Sprite into the sprites array. The other thing we do is we make sure that the Sprite, that its image is added to the DOM element, which is surface right up here. So, that's what we need to get started. I'll run it again, and looking at our two classes here, the Sprite, ps.Sprite is this pinwheel and the NS or ps.GameSurface is going to be this entire rectangle right here where we'll be showing our Sprites.

Moving A Sprite

So, now things are starting to move. We're in SpriteEngine-03. I'll go to the before folder, make sure it's our start page, the HTML file, and I'll run it first. So, now our pinwheel is moving across the game surface. Let's take a look at the code I changed. In our HTML file, I set the Sprite xSpeed property to 100. So, now it'll move 100 pixels per second in the X direction. If we wanted it to move left, we would make it -100. And then we call surface for our game surface.start. So, looking at our JavaScript and looking at the GameSurface class, here's the start function. What I'm doing is I'm saving off the this variable to self. That way it'll be trapped in this closure here, and we create a timer assigning it to the timer variable. We setInterval, so we're going to call this function every 1000 divided by the frames per second. So, we do 1000 because there are 1000 milliseconds in a second, and then we divide it by the frames per second. So, for every frame this function is going to get called. And what this function does is it loops through all the sprites, self.sprites.length, so it'll loop through. And for each sprite it will call update. And the parameter it's going to pass to update is the frames per second divided by 1000 milliseconds again. So, that's the amount of time that passes between frames. And for the fps, frames per second, we're setting that to 30 up here now. And we also have a frameDuration, which we're not really using that. So, the key thing to remember is if we ever wanted to change our frames per second we just change it right here. So, we're calling sprites update, so let's look at that. I added this code to our Sprite class. We pass it the amount of time that has passed since the last call to update or the amount of time within a frame. And we're going to adjust our X value. We're going to add our speed times the time. And the same with our Y value. We adjust it to ySpeed times the time. And then we update the CSS properties. Left will become our X value, and top will become our Y value. So essentially now we have a loop. When we start things off, we'll have this timer run continuously. And for every frame it's going to call each one of the sprites that we have in our array within the GameSurface and call update. So, I'll run it again, and we get our animation.

Animating 500 Sprites

Okay, so now we have our Sprite engine working with the timer. Let's add a whole bunch of sprites to it now. I'm in SpriteEngine.html. Make sure that's the start page, and we're in the 04 folder. And you can see that I changed the HTML file right here. So, we create our surface, but then we're going to loop and create 500 new sprites. We create the Sprite the same way, we assign it to S, and then we're going to position it right in the middle of the screen, X coordinate 240, Y coordinate 160. And then we're going to set an xSpeed, and the xSpeed is going to be set to a random number between -100 and +100. And the same with the ySpeed. It'll go from -100 up to +100. And we're not going to be doing any looping, so I'll take that out. And then we take our sprite, and we add it to the game surface. So, after we loop and create 500 of these sprites, we're ready to start. We'll kick it off. So, let's run this. And there we have the 500 sprites. So, the performance on that was pretty good. It was moving 500 sprites all together. And whether we run this on a slower device such as an iPad or you know some iOS or tablet device, it would probably be a lot slower. So, let's look at how we could possibly speed this up.

Inspecting The Code with Chrome's Profiler

So, let's set our browser over to Chrome. Chrome has a profiler. Well, Internet Explorer has a profiler as well, but I like using the Chrome profiler. It gives a little bit more information, and it's a little bit easier to read for me. So, let's run it now under Chrome. And you know looking at it now compared to Internet Explorer it does look quicker. What I'm going to do is I'm going to start up the developer tools. I have the tools installed, and I'm going to go to the Profiles tab. Now, if you haven't worked with profiling before, it's a really great way to see exactly what's going on with your code. The way that Google profiler works is it'll sample probably hundreds of times per second which function your code is in. It'll dump out a stack trace and just keep track of where your code is executing and how much time it's spending in each function. So, I'm going to Refresh it. I'm going to Refresh the screen and then quickly come down and press the Start button. So, I Refresh it, hit Start, and now we're getting all the metrics from this code that's running, and I'll hit Stop. So, the program is still running up here, but we have our metrics in the profiler. So, let's take a look at what this is doing. This column here is the Function column. I don't want to sort by that yet, but these are the functions that take up the most time when our code is executing. And if you look at the column on the far left, the Self column, this tells us what percentage of time was spent in that function. So, first of all we have idle. So, Chrome was idle 41.49% of the time, which is pretty good. I mean we're animating 500 images, so 41% of the time Chrome is just sitting around waiting. And this is only for one thread. Like I have a, I think it's a 6-core processor, but this is only measuring the one core that it's running on. Next is program. There's not much we can do about the program that's running, so I'll usually ignore this. We're more interested in improving the idle time. The faster our code performs, the higher the idle percentage will be, and that's what we want. So, going down we see the first function that gets called that's taking a lot of time. 13.71% of the time was spent in this x.extend.style function. Now, we can go directly to this function. I'll click on the link on the right. It's in jQuery. And it sent us here, but this doesn't look like the function we were looking at in Profiles. So, probably what I did is I forgot to put in the real jQuery, and I'm probably using a minified version. So, let me shut this down. And yeah, if we look at our jQuery, it is minified. So, I'm going to take the minification out, and now we can run it, and it'll be more accurate. I'll pull up the developer tools, I'll Refresh and Start, and then I'll wait a few seconds to get the performance data. I'll Stop it. Okay, now it makes more sense. Instead of x.extend.style we have jQuery.extend.style. And now the line number is going to match up a lot better. So, if we look at this style function, I'll click into it, here we go right here, get and set the style property on a DOM Node. So, this is probably called by our CSS function. And what this function is going to do is set the style property, which is the CSS property. I'll go back to Profiles. Now, if we open up this jQuery.extend.style, or before we even do that, you want to make sure that this setting down on the bottom is set to Heavy (Bottom Up), and that's how I get it ordered like this. If you see it ordered something like this, this is a Top Down ordering, and that's just not as useful for what we need right now. Or there's a Flame Chart, which I haven't really worked with much. But looking at the Heavy (Bottom Up) we can click on our function we're interested in improving, and we can see who calls it. So, it's called by this anonymous function, which is in jQuery itself. Let's go there. And this is the anonymous function it's referring to, and this ultimately gets called by CSS. So, it is our CSS function call that is eating up most of the time. Going back to the Profiles. So, we know this is caused by our CSS call, and everything else looks pretty good. Everything is much slower than 13.17%. So, let's focus on trying to improve our CSS call. So remember the way it is now is about 41% approximately idle, and we want to try to raise that as high as we can.

Optimizing our Code

Alright, so I'm in SpriteEngine-06, and we'll pull up the SpriteEngine.js. Make sure your start page is set to the HTML page. So, here we can see our two CSS calls, and this is what's taking up the bulk of our time is calling this CSS method. So, how can we speed this up? One way is we could go through the function and see how it's working. Most likely it's probably doing things like adding the PX for us, and it's looking up vendor prefixes, but we know that the left and top don't have any vendor prefixes. I mean those are pretty much standard across all browsers. So, let's comment these out, and I'm going to rewrite these calling the actual DOM element. Okay, so I'm taking the image, already a value of 0, which is the actual DOM element, and I'm looking at the style property, which is our CSS property, and we're taking left. And we're setting it to this.x, and we're going to add the pixels to it because that's something that jQuery usually does for us. And we're doing the same thing with the top. We're going to set it to Y dot PX. So, let's run it now. So, it looks the same as before. It's running okay. Let's try it with the developer tools now. I'll hit F12, and I'll Refresh and hit Start really quick, wait a few seconds, and hit Stop. So, looking at our idle, before it was like in the low 40s, and now we're idle about 57%. So, we did get a big jump in our idle time, which is great. That gives us more time to do other processing. I'm looking at our update function. Before we were using jQuery to call CSS, but now it looks like that processing time has gone into update instead. If we click on the source code here, yeah this is the update that we just fixed, and it looks like setting CSS properties is pretty expensive. But going back to the profiles where it took 13% of the time before, now it's only about 8%. So, we really did fix this up a lot. So, when it comes to speeding up jQuery animations, it looks like calling CSS is pretty expensive. Plus it also seems less expensive just to create one animation loop. By having our GameSurface and holding onto a timer that we can start and we can also stop it, now we have one timer, and we update all our sprites every frame, we avoid a lot of the overhead from jQuery, we avoid all the calls into the step handler or the completed handler, and we handle it all on our own. So, looking at the animation again, if you ever have a large number of sprites you need to animate, whether it's a game or some kind of simulation or some kind of particle effects, using jQuery, and especially using the jQuery CSS method, probably isn't the way to go. You want to create your own loop and keep track of your hundreds of elements by themselves. But if you need to use jQuery, it doesn't add that much of an overhead.

Summary

In this module, we built a simple Sprite engine. We created our own animation timer so that we weren't bound by jQuery's requirement of specifying a time limit for our animation. We created a Sprite class and a GameSurface class to show our Sprites in motion. The Chrome profiler is a great tool to help us understand the performance of our JavaScript code. We used Chrome's profiler to help improve the performance of our Sprite engine. Well, that brings this course to an end. I hope you got a lot from this course and you create some really cool animations for your websites and apps. Feel free to contact me for advice on your own animation projects, and I'm always interested in checking out your great new animations on the web.

